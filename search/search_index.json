{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Isomorphic Layout Composer (ILC) - layout service that compose a web page from fragment services. It supports client/server based page composition. It's key difference and advantage against other solutions lays in the fact that it does page composition isomorphically. It means that page will be assembled at server side using apps that support server side rendering (SSR) and after that it will be hydrated at client side so all further navigation will be handled by client side rendering. Such approach allows to combine advantages of the Micro Frontends , SPA & Server Side Rendering approaches . This repository also contains an example of how you can create a front-end that is composed from multiple applications which work in concert and deliver unified experience. Why do I need ILC? \u2693\ufe0e Microservices get a lot of traction these days. They allow multiple teams to work independently from each other, choose their own technology stacks and establish their own release cycles. Unfortunately, frontend development hasn\u2019t fully capitalized yet on the benefits that microservices offer. The common practice for building websites remains \u201cthe monolith\u201d: a single frontend codebase that consumes multiple APIs. What if we could have microservices on the frontend? This would allow frontend developers to work together with their backend counterparts on the same feature and independently deploy parts of the website \u2014 \u201cfragments\u201d such as Header, Product, and Footer. Bringing microservices to the frontend requires a layout service that composes a website out of fragments. ILC was developed to solve this need. Key features \u2693\ufe0e \ud83d\udce6 Based on single-spa & TailorX - battle tested solutions inside \ud83d\udcf1 Technology Agnostic - use it with React, Vue.js, Angular, etc... \u2699\ufe0f Server Side Rendering support - key advantage over competitors \ud83d\uddc4 Built-in registry - add new apps, pages or change configs and templates in few clicks. More info here . \u26a1\ufe0f Built for speed - server side part of the system adds just ~17ms of latency \ud83d\udc68\u200d\ud83d\udcbb Develop right at production - Doc \ud83c\udf10 Internationalization support - it is ready to serve your clients from any country. Doc , Demo with localized navbar \ud83d\udce1 Other advanced features: Parcels Plugins App Wrappers \ud83d\udcb2 Backed by Namecheap - we use it internally and plan to evolve it together with community \ud83d\ude80 Quick start \u2693\ufe0e Check out demo website available online or go through the steps to spin it up locally: Get familiar with Installation guide Clone this repository Run docker compose up -d During first launch or shutdown only. Run docker compose run registry npm run seed PROFIT \ud83d\ude0e View logs via docker compose logs -f --tail=10 Open ILC at http://localhost:8233/ Open Registry UI at http://localhost:4001/ & use root/pwd credentials to sign in. Shutdown everything with docker compose down More information about demo applications used in this quick start you can find here . And don't miss the Step-By-Step lessons about apps development with ILC . Architecture overview \u2693\ufe0e Repo structure \u2693\ufe0e |\u2013 ilc: code of the Isomorphic Layout Composer |\u2013 registry: app that contains configuration used by ILC. Such as list of micro-fragments, routes, etc... Further reading \u2693\ufe0e Installation guide Micro-frontend Types Step-By-Step lessons about apps development with ILC ILC to App interface ILC Registry Animation during reroute Global error handling Demo applications used in quick start SDK for ILC plugins development Compatibility with legacy UMD bundles Global API ILC transition hooks Multi-domains Public Path Problem \ud83d\udd0c Adapters \u2693\ufe0e To conveniently connect various frameworks to ILC we rely on the ecosystem of the single-spa provided adapters. However sometimes we need to extend original ones to deliver better integration with ILC. Here are the list of the adapters that were forked & modified: React - ilc-adapter-react Vue.js - ilc-adapter-vue Notes \u2693\ufe0e Why @portal/ \u2693\ufe0e We're using webpack (a static module bundler) to build each application for our micro-frontend approach. Webpack requires access to everything it needs to include in the bundle at build time. This means when an app that imports a service, for example planets importing the fetchWithCache service, webpack will try to bundle the service into the planets bundle. The built in way to avoid webpack doing this is webpack externals , using externals works really well but to avoid having to include a regex for each service I'm using the postfix to signal to webpack (and developers) that the import is another micro-app/service/front-end. The prefix isn't required if you would rather include a different postfix or none at all it should work, you'll just have to modify each webpack config for externals. Code splitting \u2693\ufe0e Code splitting is a complicated topic. I'm not going to dive into each facet of it within Webpack, see Webpacks docs for that . In our project code splitting is further complicated because webpack's module format expects to load more modules from the website root, which will always fail in this project unless webpack is told where to load additional modules. Right now there is a single example of this, done in the people application .","title":"Home"},{"location":"#why-do-i-need-ilc","text":"Microservices get a lot of traction these days. They allow multiple teams to work independently from each other, choose their own technology stacks and establish their own release cycles. Unfortunately, frontend development hasn\u2019t fully capitalized yet on the benefits that microservices offer. The common practice for building websites remains \u201cthe monolith\u201d: a single frontend codebase that consumes multiple APIs. What if we could have microservices on the frontend? This would allow frontend developers to work together with their backend counterparts on the same feature and independently deploy parts of the website \u2014 \u201cfragments\u201d such as Header, Product, and Footer. Bringing microservices to the frontend requires a layout service that composes a website out of fragments. ILC was developed to solve this need.","title":"Why do I need ILC?"},{"location":"#key-features","text":"\ud83d\udce6 Based on single-spa & TailorX - battle tested solutions inside \ud83d\udcf1 Technology Agnostic - use it with React, Vue.js, Angular, etc... \u2699\ufe0f Server Side Rendering support - key advantage over competitors \ud83d\uddc4 Built-in registry - add new apps, pages or change configs and templates in few clicks. More info here . \u26a1\ufe0f Built for speed - server side part of the system adds just ~17ms of latency \ud83d\udc68\u200d\ud83d\udcbb Develop right at production - Doc \ud83c\udf10 Internationalization support - it is ready to serve your clients from any country. Doc , Demo with localized navbar \ud83d\udce1 Other advanced features: Parcels Plugins App Wrappers \ud83d\udcb2 Backed by Namecheap - we use it internally and plan to evolve it together with community","title":"Key features"},{"location":"#quick-start","text":"Check out demo website available online or go through the steps to spin it up locally: Get familiar with Installation guide Clone this repository Run docker compose up -d During first launch or shutdown only. Run docker compose run registry npm run seed PROFIT \ud83d\ude0e View logs via docker compose logs -f --tail=10 Open ILC at http://localhost:8233/ Open Registry UI at http://localhost:4001/ & use root/pwd credentials to sign in. Shutdown everything with docker compose down More information about demo applications used in this quick start you can find here . And don't miss the Step-By-Step lessons about apps development with ILC .","title":"\ud83d\ude80 Quick start"},{"location":"#architecture-overview","text":"","title":"Architecture overview"},{"location":"#repo-structure","text":"|\u2013 ilc: code of the Isomorphic Layout Composer |\u2013 registry: app that contains configuration used by ILC. Such as list of micro-fragments, routes, etc...","title":"Repo structure"},{"location":"#further-reading","text":"Installation guide Micro-frontend Types Step-By-Step lessons about apps development with ILC ILC to App interface ILC Registry Animation during reroute Global error handling Demo applications used in quick start SDK for ILC plugins development Compatibility with legacy UMD bundles Global API ILC transition hooks Multi-domains Public Path Problem","title":"Further reading"},{"location":"#adapters","text":"To conveniently connect various frameworks to ILC we rely on the ecosystem of the single-spa provided adapters. However sometimes we need to extend original ones to deliver better integration with ILC. Here are the list of the adapters that were forked & modified: React - ilc-adapter-react Vue.js - ilc-adapter-vue","title":"\ud83d\udd0c Adapters"},{"location":"#notes","text":"","title":"Notes"},{"location":"#why-portal","text":"We're using webpack (a static module bundler) to build each application for our micro-frontend approach. Webpack requires access to everything it needs to include in the bundle at build time. This means when an app that imports a service, for example planets importing the fetchWithCache service, webpack will try to bundle the service into the planets bundle. The built in way to avoid webpack doing this is webpack externals , using externals works really well but to avoid having to include a regex for each service I'm using the postfix to signal to webpack (and developers) that the import is another micro-app/service/front-end. The prefix isn't required if you would rather include a different postfix or none at all it should work, you'll just have to modify each webpack config for externals.","title":"Why @portal/"},{"location":"#code-splitting","text":"Code splitting is a complicated topic. I'm not going to dive into each facet of it within Webpack, see Webpacks docs for that . In our project code splitting is further complicated because webpack's module format expects to load more modules from the website root, which will always fail in this project unless webpack is told where to load additional modules. Right now there is a single example of this, done in the people application .","title":"Code splitting"},{"location":"CONTRIBUTING/","text":"Contributing to Isomorphic Layout Composer \u2693\ufe0e Thank you for your interest in making ILC even better and more awesome. Your contributions are highly welcome. Installation and setup of the LDE \u2693\ufe0e Clone the repo For Namecheap employees only : clone \" ilc.internal \" repo and follow the guide to setup NC specific applications. Run npm install Run npm start PROFIT \ud83d\ude0e Open running code at http://localhost:8233/ Registry UI is available at http://localhost:4001/ These steps will start ILC with a set of demo applications running inside Docker container. While it's ok in most of the cases - sometimes you might need to develop those apps alongside ILC. To do so you need to clone ilc-demo-apps repo and run them in dev mode. At the same time in parallel terminal you need to run npm run start:no-apps E2E tests \u2693\ufe0e To make sure that all ILC components play well together we use E2E tests. We use our Demo applications as test micro frontends so it also gives us ability to make sure that we don't break backward compatibility. In order to run tests: Build ILC & Registry by running npm run build Change your current directory to ./e2e Launch one of the following commands: Default mode: npm start Verbose mode: npm run start:verbose Verbose mode with Browser UI visible: npm run start:verbose:ui Debug mode \u2693\ufe0e ILC uses debug package at client side to produce verbose logs for debug purposes. To enable it, execute localStorage.debug = 'ILC:*' in the browser console. Documentation website \u2693\ufe0e Build docker image for docs: docker build -t ilc-mkdocs - < ./.mkdocs/Dockerfile Watch or build docs: Dev mode (watch) : docker run --rm -it -p 8000:8000 -v ${PWD}:/docs ilc-mkdocs Build : docker run --rm -v ${PWD}:/docs ilc-mkdocs build","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-isomorphic-layout-composer","text":"Thank you for your interest in making ILC even better and more awesome. Your contributions are highly welcome.","title":"Contributing to Isomorphic Layout Composer"},{"location":"CONTRIBUTING/#installation-and-setup-of-the-lde","text":"Clone the repo For Namecheap employees only : clone \" ilc.internal \" repo and follow the guide to setup NC specific applications. Run npm install Run npm start PROFIT \ud83d\ude0e Open running code at http://localhost:8233/ Registry UI is available at http://localhost:4001/ These steps will start ILC with a set of demo applications running inside Docker container. While it's ok in most of the cases - sometimes you might need to develop those apps alongside ILC. To do so you need to clone ilc-demo-apps repo and run them in dev mode. At the same time in parallel terminal you need to run npm run start:no-apps","title":"Installation and setup of the LDE"},{"location":"CONTRIBUTING/#e2e-tests","text":"To make sure that all ILC components play well together we use E2E tests. We use our Demo applications as test micro frontends so it also gives us ability to make sure that we don't break backward compatibility. In order to run tests: Build ILC & Registry by running npm run build Change your current directory to ./e2e Launch one of the following commands: Default mode: npm start Verbose mode: npm run start:verbose Verbose mode with Browser UI visible: npm run start:verbose:ui","title":"E2E tests"},{"location":"CONTRIBUTING/#debug-mode","text":"ILC uses debug package at client side to produce verbose logs for debug purposes. To enable it, execute localStorage.debug = 'ILC:*' in the browser console.","title":"Debug mode"},{"location":"CONTRIBUTING/#documentation-website","text":"Build docker image for docs: docker build -t ilc-mkdocs - < ./.mkdocs/Dockerfile Watch or build docs: Dev mode (watch) : docker run --rm -it -p 8000:8000 -v ${PWD}:/docs ilc-mkdocs Build : docker run --rm -v ${PWD}:/docs ilc-mkdocs build","title":"Documentation website"},{"location":"LICENSE/","text":"Copyright 2020 Namecheap, Inc \u2693\ufe0e Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"LICENSE/#copyright-2020-namecheap-inc","text":"Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Copyright 2020 Namecheap, Inc"},{"location":"NOTICE/","text":"This product contains a modified version of Justin McMurdie's \"single-spa-portal-example\", which can be obtained at: LICENSE: ISC HOMEPAGE: https://gitlab.com/TheMcMurder/single-spa-portal-example This product contains a modified version of Sam Stephenson's \"Prototype JavaScript Framework\", which can be obtained at: LICENSE: Custom HOMEPAGE: https://github.com/prototypejs/prototype","title":"Notice"},{"location":"docs/animation_during_reroute/","text":"Animation during reroute \u2693\ufe0e Demo \u2693\ufe0e Implementation details \u2693\ufe0e Spinner appears only if transition from one route to another took more then 200ms. During transition ILC remove original MSs immediately and place fake cloned nodes to DOM, which in relust don't have any JS mouse listeners. so we strongly recommend to use backdrop for spinner. In any case, additionally it will cover any your bugs regarding interaction users with site during rerouting. How to customize default spinner \u2693\ufe0e You can use your own spinner by setting globalSpinner.customHTML parameter via ILC Registry settings page. Also you can turn off global spinner completely by changing globalSpinner.enabled parameter in Registry.","title":"Animation during reroute"},{"location":"docs/animation_during_reroute/#animation-during-reroute","text":"","title":"Animation during reroute"},{"location":"docs/animation_during_reroute/#demo","text":"","title":"Demo"},{"location":"docs/animation_during_reroute/#implementation-details","text":"Spinner appears only if transition from one route to another took more then 200ms. During transition ILC remove original MSs immediately and place fake cloned nodes to DOM, which in relust don't have any JS mouse listeners. so we strongly recommend to use backdrop for spinner. In any case, additionally it will cover any your bugs regarding interaction users with site during rerouting.","title":"Implementation details"},{"location":"docs/animation_during_reroute/#how-to-customize-default-spinner","text":"You can use your own spinner by setting globalSpinner.customHTML parameter via ILC Registry settings page. Also you can turn off global spinner completely by changing globalSpinner.enabled parameter in Registry.","title":"How to customize default spinner"},{"location":"docs/app_wrappers/","text":"Wrapper for Applications \u2693\ufe0e Note: This is an advanced feature of ILC. In most of the cases you won't need it. This feature is useful if you want to extract some bootstrap, loading or authorization functionality from different apps and being able to control it from a single place. This is useful if you're building a store where pages for different products will be developed by different teams and so will reside in different Micro Frontends. In this case you may want to extract logic that check if product has been already purchased by the customer to standalone app which would perform the check and render some UI for purchase if necessary. Registry configuration \u2693\ufe0e To use this feature you need to have ILC Registry configured in the following way: Register App Wrapper app in Registry and set it's kind property to wrapper . For the apps that you want to wrap with Wrapper - set wrappedWith property to the name of the app from the 1st step. Notes: - It's impossible to use apps with kind = wrapper in routes directly. - If Wrapper App doesn't support SSR - it's will be ignored for all wrapped apps. So remember: if you need to create wrapper for apps with SRR - wrapper also should be SSR capable. How to build App Wrapper \u2693\ufe0e Essentially App Wrapper is a regular ILC application which receives extra property which allows to render target application with optional extra props when needed. Look at the demo wrapper for reference implementation . To see it in action go to our demo website . Client side API \u2693\ufe0e At client side Wrapper App receives an additional property renderApp via ILC to App interface . Server side API \u2693\ufe0e At server side application should be using IlcAppWrapperSdk from ilc-sdk instead of the regular IlcSdk class. It exposes additional forwardRequest method which can be used to forward SSR request to target app and so render it immediately at client side w/o even executing App Wrapper's code during initial CSR on page load.","title":"App Wrappers"},{"location":"docs/app_wrappers/#wrapper-for-applications","text":"Note: This is an advanced feature of ILC. In most of the cases you won't need it. This feature is useful if you want to extract some bootstrap, loading or authorization functionality from different apps and being able to control it from a single place. This is useful if you're building a store where pages for different products will be developed by different teams and so will reside in different Micro Frontends. In this case you may want to extract logic that check if product has been already purchased by the customer to standalone app which would perform the check and render some UI for purchase if necessary.","title":"Wrapper for Applications"},{"location":"docs/app_wrappers/#registry-configuration","text":"To use this feature you need to have ILC Registry configured in the following way: Register App Wrapper app in Registry and set it's kind property to wrapper . For the apps that you want to wrap with Wrapper - set wrappedWith property to the name of the app from the 1st step. Notes: - It's impossible to use apps with kind = wrapper in routes directly. - If Wrapper App doesn't support SSR - it's will be ignored for all wrapped apps. So remember: if you need to create wrapper for apps with SRR - wrapper also should be SSR capable.","title":"Registry configuration"},{"location":"docs/app_wrappers/#how-to-build-app-wrapper","text":"Essentially App Wrapper is a regular ILC application which receives extra property which allows to render target application with optional extra props when needed. Look at the demo wrapper for reference implementation . To see it in action go to our demo website .","title":"How to build App Wrapper"},{"location":"docs/app_wrappers/#client-side-api","text":"At client side Wrapper App receives an additional property renderApp via ILC to App interface .","title":"Client side API"},{"location":"docs/app_wrappers/#server-side-api","text":"At server side application should be using IlcAppWrapperSdk from ilc-sdk instead of the regular IlcSdk class. It exposes additional forwardRequest method which can be used to forward SSR request to target app and so render it immediately at client side w/o even executing App Wrapper's code during initial CSR on page load.","title":"Server side API"},{"location":"docs/develop_at_production/","text":"Develop right at \"production\" \u2693\ufe0e ILC gives you ability to develop your Micro Frontends in context of the \"production\" environment. This means that you can render your new app or changed version of the existing one right at the production website. This gives you ability to see the final result sooner w/o necessity to mock other Micro Frontends inside your local development environment. Practical example, how to develop your app within our demo site \u2693\ufe0e Let's imagine that our demo site is your production environment. And let's try to substitute News app with the one that you'll run locally. Run our demo apps locally. To do so, follow the instruction here ilc-demo-apps#development-process . If you're behind NAT and don't have \"white\" IP address on your machine - use ngrok or any another similar tool to create public url for exposing your local apps. Download & install ngrok using instruction from their website. As News app uses 8239 port \u2013 run ngrok http 8239 and you will receive your exposed url, e.g. http://c6960219.ngrok.io . Open demo site and add next cookies: const exposedUrl = 'http://c6960219.ngrok.io' ; // or if you don't have NAT - http://YOUR_PUBLIC_IP:8239 const overrideConfig = encodeURIComponent ( JSON . stringify ({ apps : { '@portal/news' : { spaBundle : exposedUrl + '/dist/single_spa.js' , cssBundle : exposedUrl + '/dist/common.css' , ssr : { src : exposedUrl + '/news/?fragment=1' , }, props : { publicPath : exposedUrl + '/dist/' , }, }, }, })); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;` Try to refresh http://demo.microfrontends.online/news/ several times & using \"Network\" tabs in browser dev tools ensure that some requests now go to the URL we specified before in exposedUrl variable. Now let's try to make some changes in our local News app and see them appeared at our Demo website. Go to cloned ilc-demo-apps repo, open the file /ilc-demo-apps/apps/news-ssr/src/components/Home.vue and replace <h1>Pick a news source</h1> with <h1>Hello world</h1> . Now switch to your browser and refresh page http://demo.microfrontends.online/news/ . If everything is ok, you will see h1 with text \"Hello world\". Last step is to check that SSR works correctly: Turn off javascript with the help of dev-tools in your browser. e.g. explanation how to do it for Chrome And after reload of the page we still see correct page with h1 - Hello world Security considerations \u2693\ufe0e The fact that you can override ILC config for particular browser using cookies introduces a risk of having website defacement attack with the help of XSS . To mitigate this risk ILC by default will restrict all domains and all real IPs (only private IPv4 addresses are allowed) specified for all links in configuration. However you can allow additional origins via property \"overrideConfigTrustedOrigins\", on \"Settings\" page of ILC Registry. - default - any origin is disallowed, except for private IPv4 addresses - all - trust any origins - foo.com, bar.com - trust only foo.com and bar.com (recommended) Creating own MS \u2693\ufe0e first of all, you should take adapter for your framework, wrap your app with it and export lifecycle functions. turn off CORS for development environment. e.g. for Webpack just add to config: devServer : { headers : { \"Access-Control-Allow-Origin\" : \"*\" , }, } your MS bundle file must be wrapped with(for Webpack you can use wrapper-webpack-plugin ): \"(function(define){\\n\" + bundle_content + \"\\n})((window.ILC && window.ILC.define) || window.define);\" your MS should be publicly available. e.g. hosted under 0.0.0.0( default for Node http, so for express too ) and available under your IP address or any other tools e.g ngrok or smth else. add \"ILC-overrideConfig\" cookie with config to production: const overrideConfig = encodeURIComponent ( JSON . stringify ({ \"apps\" : { // rewrite existed MS \"@portal/NAME1\" : { \"spaBundle\" : \"http://10.1.150.85:2273/bundle.js\" , // url to bundle \"ssr\" : { \"src\" : \"http://10.1.150.85:2273/\" , // url to ssr }, }, // add new MS \"@portal/NAME2\" : { \"spaBundle\" : \"http://10.1.150.85:9892/bundle.js\" , // url to bundle \"ssr\" : { \"src\" : \"http://10.1.150.85:9891/\" , // url to ssr \"timeout\" : 1000 , }, \"kind\" : \"primary\" , }, }, // add new MS slot to certain route \"routes\" : [ { \"routeId\" : 103 , \"route\" : \"/example/\" , \"next\" : false , \"slots\" : { \"body\" : { \"appName\" : \"@portal/NAME2\" , \"kind\" : null }, }, }, ], }) ); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;` since you probably run your MS locally via http and if your production site uses https so you will have problems with mixed content when you try to send request to http from https, so the simplest way to resolve it - just turn off checking in your browser. Details link . if you exclude some libs e.g. via \"externals\" property of webpack config - comment it during developing at production. Shared libraries \u2693\ufe0e Shared libraries support the same way of developing like MSs. You just need to provide library name (w/o prefix \"@sharedLibrary/\") and path to spa-bundle: const overrideConfig = encodeURIComponent ( JSON . stringify ({ \"sharedLibs\" : { \"sampleLibrary\" : { \"spaBundle\" : 'http://10.1.150.85:9001/bundle.js' , }, }, }) ); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;`","title":"Develop at Production"},{"location":"docs/develop_at_production/#develop-right-at-production","text":"ILC gives you ability to develop your Micro Frontends in context of the \"production\" environment. This means that you can render your new app or changed version of the existing one right at the production website. This gives you ability to see the final result sooner w/o necessity to mock other Micro Frontends inside your local development environment.","title":"Develop right at \"production\""},{"location":"docs/develop_at_production/#practical-example-how-to-develop-your-app-within-our-demo-site","text":"Let's imagine that our demo site is your production environment. And let's try to substitute News app with the one that you'll run locally. Run our demo apps locally. To do so, follow the instruction here ilc-demo-apps#development-process . If you're behind NAT and don't have \"white\" IP address on your machine - use ngrok or any another similar tool to create public url for exposing your local apps. Download & install ngrok using instruction from their website. As News app uses 8239 port \u2013 run ngrok http 8239 and you will receive your exposed url, e.g. http://c6960219.ngrok.io . Open demo site and add next cookies: const exposedUrl = 'http://c6960219.ngrok.io' ; // or if you don't have NAT - http://YOUR_PUBLIC_IP:8239 const overrideConfig = encodeURIComponent ( JSON . stringify ({ apps : { '@portal/news' : { spaBundle : exposedUrl + '/dist/single_spa.js' , cssBundle : exposedUrl + '/dist/common.css' , ssr : { src : exposedUrl + '/news/?fragment=1' , }, props : { publicPath : exposedUrl + '/dist/' , }, }, }, })); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;` Try to refresh http://demo.microfrontends.online/news/ several times & using \"Network\" tabs in browser dev tools ensure that some requests now go to the URL we specified before in exposedUrl variable. Now let's try to make some changes in our local News app and see them appeared at our Demo website. Go to cloned ilc-demo-apps repo, open the file /ilc-demo-apps/apps/news-ssr/src/components/Home.vue and replace <h1>Pick a news source</h1> with <h1>Hello world</h1> . Now switch to your browser and refresh page http://demo.microfrontends.online/news/ . If everything is ok, you will see h1 with text \"Hello world\". Last step is to check that SSR works correctly: Turn off javascript with the help of dev-tools in your browser. e.g. explanation how to do it for Chrome And after reload of the page we still see correct page with h1 - Hello world","title":"Practical example, how to develop your app within our demo site"},{"location":"docs/develop_at_production/#security-considerations","text":"The fact that you can override ILC config for particular browser using cookies introduces a risk of having website defacement attack with the help of XSS . To mitigate this risk ILC by default will restrict all domains and all real IPs (only private IPv4 addresses are allowed) specified for all links in configuration. However you can allow additional origins via property \"overrideConfigTrustedOrigins\", on \"Settings\" page of ILC Registry. - default - any origin is disallowed, except for private IPv4 addresses - all - trust any origins - foo.com, bar.com - trust only foo.com and bar.com (recommended)","title":"Security considerations"},{"location":"docs/develop_at_production/#creating-own-ms","text":"first of all, you should take adapter for your framework, wrap your app with it and export lifecycle functions. turn off CORS for development environment. e.g. for Webpack just add to config: devServer : { headers : { \"Access-Control-Allow-Origin\" : \"*\" , }, } your MS bundle file must be wrapped with(for Webpack you can use wrapper-webpack-plugin ): \"(function(define){\\n\" + bundle_content + \"\\n})((window.ILC && window.ILC.define) || window.define);\" your MS should be publicly available. e.g. hosted under 0.0.0.0( default for Node http, so for express too ) and available under your IP address or any other tools e.g ngrok or smth else. add \"ILC-overrideConfig\" cookie with config to production: const overrideConfig = encodeURIComponent ( JSON . stringify ({ \"apps\" : { // rewrite existed MS \"@portal/NAME1\" : { \"spaBundle\" : \"http://10.1.150.85:2273/bundle.js\" , // url to bundle \"ssr\" : { \"src\" : \"http://10.1.150.85:2273/\" , // url to ssr }, }, // add new MS \"@portal/NAME2\" : { \"spaBundle\" : \"http://10.1.150.85:9892/bundle.js\" , // url to bundle \"ssr\" : { \"src\" : \"http://10.1.150.85:9891/\" , // url to ssr \"timeout\" : 1000 , }, \"kind\" : \"primary\" , }, }, // add new MS slot to certain route \"routes\" : [ { \"routeId\" : 103 , \"route\" : \"/example/\" , \"next\" : false , \"slots\" : { \"body\" : { \"appName\" : \"@portal/NAME2\" , \"kind\" : null }, }, }, ], }) ); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;` since you probably run your MS locally via http and if your production site uses https so you will have problems with mixed content when you try to send request to http from https, so the simplest way to resolve it - just turn off checking in your browser. Details link . if you exclude some libs e.g. via \"externals\" property of webpack config - comment it during developing at production.","title":"Creating own MS"},{"location":"docs/develop_at_production/#shared-libraries","text":"Shared libraries support the same way of developing like MSs. You just need to provide library name (w/o prefix \"@sharedLibrary/\") and path to spa-bundle: const overrideConfig = encodeURIComponent ( JSON . stringify ({ \"sharedLibs\" : { \"sampleLibrary\" : { \"spaBundle\" : 'http://10.1.150.85:9001/bundle.js' , }, }, }) ); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;`","title":"Shared libraries"},{"location":"docs/global_api/","text":"Global API \u2693\ufe0e Global API documentation","title":"Global API"},{"location":"docs/global_api/#global-api","text":"Global API documentation","title":"Global API"},{"location":"docs/global_errors_handling/","text":"Global error handling with ILC \u2693\ufe0e Introduction of Micro Frontends architecture brings new challenges to the board that need to be solved. One of those challenges is handling of the 5XX & 4XX error pages. As your web page now is composed from several fragments you can't use the same approach you used to have with monolithic frontend. This is the moment when ILC comes to the stage. Types of the apps \u2693\ufe0e Primary - app which is \"responsible\" for the current route, usually this app renders main consumable page content. At a particular route you may have only a single primary app. During SSR this app will supply HTTP response code & headers in the response to the client. Essential - app which is treated as an essential part of the page. Should be applied only to the ones w/o which page makes no sense to the user. Typical example is a website header. Regular - app which provides supplementary functionality on the page. Page can be effectively consumed by users w/o such apps rendered. Example: footer, ads, promo banners \"5XX\" errors (unexpected errors) \u2693\ufe0e Handling of the unexpected errors varies between SSR & CSR (as well it depends on the type of the app) due to the natural differences between server & client. So keep an eye on it. It's also worth saying that there is no such thing as 5XX error at the client side. However we use this term at the client side as well to simplify & unify things a bit. Primary apps SSR: all 5XX response codes will trigger appearance of the 500 error page configured in ILC CSR: any error caught by ILC errorHander or errors during loading/mounting - will trigger appearance of the 500 error page configured in ILC Essential apps SSR: all non 2XX response codes will be treated as SSR error and 2nd rendering attempt will be done at client side.\\ However if we handle request from SEO/SM bot - 500 error page configured in ILC will be shown. CSR: any error caught by ILC errorHander or errors during loading/mounting - will trigger appearance of the 500 error page configured in ILC Regular SSR: all non 2XX response codes will be treated as SSR error and 2nd rendering attempt will be done at client side. CSR: any error caught by ILC errorHander or errors during loading/mounting - will be logged w/o any further actions \"404\" error (Not found) \u2693\ufe0e This is a very common error in web applications & usually it means that we want to show some message to the user that requested resource was not found on the server. With the introduction of the micro frontends & global ILC router things become a little bit trickier. It means that we may catch this error at 2 different routing layers: ILC Router \u2013 if there is no route configured in Registry for requested URL - it will trigger an appearance of the special 404 route ( Namecheap example ). This logic will work seamlessly between SSR & CSR. Ex: /nosuchpath url was requested. Or try http://demo.microfrontends.online/nosuchpath App Router \u2013 ( only for primary apps ) there also may be cases when we have a route configured in Registry, however the app which is responsible for the page - fails to find the requested resource by it's ID. Imagine that you're trying to open a page of the non-existing product. Here there are 2 ways for the app to handle this case: Fallback to global 404 page - recommended approach, in this case app's content will be abandoned and users will see content of the special 404 route. To do this at CSR/SSR do the following: SSR: respond with 404 HTTP code CSR: trigger ilc:404 event on window with the following parameters: appId - application ID that was passed by ILC to the app App specific 404 page - use this only if you need to show some custom UI. To do this at CSR/SSR do the following: SSR: respond with 404 HTTP code & X-ILC-Override: error-page-content response header CSR: render custom UI you need w/o firing any events \"401\" & \"403\" errors (Unauthorized / Forbidden) \u2693\ufe0e \u0421urrently ILC has no special logic in place. May be reconsidered in the future.","title":"Global error handling"},{"location":"docs/global_errors_handling/#global-error-handling-with-ilc","text":"Introduction of Micro Frontends architecture brings new challenges to the board that need to be solved. One of those challenges is handling of the 5XX & 4XX error pages. As your web page now is composed from several fragments you can't use the same approach you used to have with monolithic frontend. This is the moment when ILC comes to the stage.","title":"Global error handling with ILC"},{"location":"docs/global_errors_handling/#types-of-the-apps","text":"Primary - app which is \"responsible\" for the current route, usually this app renders main consumable page content. At a particular route you may have only a single primary app. During SSR this app will supply HTTP response code & headers in the response to the client. Essential - app which is treated as an essential part of the page. Should be applied only to the ones w/o which page makes no sense to the user. Typical example is a website header. Regular - app which provides supplementary functionality on the page. Page can be effectively consumed by users w/o such apps rendered. Example: footer, ads, promo banners","title":"Types of the apps"},{"location":"docs/global_errors_handling/#5xx-errors-unexpected-errors","text":"Handling of the unexpected errors varies between SSR & CSR (as well it depends on the type of the app) due to the natural differences between server & client. So keep an eye on it. It's also worth saying that there is no such thing as 5XX error at the client side. However we use this term at the client side as well to simplify & unify things a bit. Primary apps SSR: all 5XX response codes will trigger appearance of the 500 error page configured in ILC CSR: any error caught by ILC errorHander or errors during loading/mounting - will trigger appearance of the 500 error page configured in ILC Essential apps SSR: all non 2XX response codes will be treated as SSR error and 2nd rendering attempt will be done at client side.\\ However if we handle request from SEO/SM bot - 500 error page configured in ILC will be shown. CSR: any error caught by ILC errorHander or errors during loading/mounting - will trigger appearance of the 500 error page configured in ILC Regular SSR: all non 2XX response codes will be treated as SSR error and 2nd rendering attempt will be done at client side. CSR: any error caught by ILC errorHander or errors during loading/mounting - will be logged w/o any further actions","title":"\"5XX\" errors (unexpected errors)"},{"location":"docs/global_errors_handling/#404-error-not-found","text":"This is a very common error in web applications & usually it means that we want to show some message to the user that requested resource was not found on the server. With the introduction of the micro frontends & global ILC router things become a little bit trickier. It means that we may catch this error at 2 different routing layers: ILC Router \u2013 if there is no route configured in Registry for requested URL - it will trigger an appearance of the special 404 route ( Namecheap example ). This logic will work seamlessly between SSR & CSR. Ex: /nosuchpath url was requested. Or try http://demo.microfrontends.online/nosuchpath App Router \u2013 ( only for primary apps ) there also may be cases when we have a route configured in Registry, however the app which is responsible for the page - fails to find the requested resource by it's ID. Imagine that you're trying to open a page of the non-existing product. Here there are 2 ways for the app to handle this case: Fallback to global 404 page - recommended approach, in this case app's content will be abandoned and users will see content of the special 404 route. To do this at CSR/SSR do the following: SSR: respond with 404 HTTP code CSR: trigger ilc:404 event on window with the following parameters: appId - application ID that was passed by ILC to the app App specific 404 page - use this only if you need to show some custom UI. To do this at CSR/SSR do the following: SSR: respond with 404 HTTP code & X-ILC-Override: error-page-content response header CSR: render custom UI you need w/o firing any events","title":"\"404\" error (Not found)"},{"location":"docs/global_errors_handling/#401-403-errors-unauthorized-forbidden","text":"\u0421urrently ILC has no special logic in place. May be reconsidered in the future.","title":"\"401\" &amp; \"403\" errors (Unauthorized / Forbidden)"},{"location":"docs/i18n/","text":"Internationalization \u2693\ufe0e ILC comes with built in internationalization support, so you can easily run micro frontends on the websites which require support of the multiple languages. However, you need to keep in mind that ILC does only part of the job for you. Support of the i18n capabilities from the micro frontends side is required. Routing \u2693\ufe0e ILC uses 2-tier routing model. It means that: 1. ILC itself handles only global routing (says which set of apps should be loaded at particular URL) 2. Micro Frontend has own routing in place which determines component to be rendered. 1st tier - ILC \u2693\ufe0e While having i18n feature enabled - ILC allows you to handle localized URLs at global level. Currently, we support two routing schemes: - Prefixing all routes with the locale except those of the default locale - Prefixing all routes with the locale In Registry, you continue to specify all routes in Registry w/o locale information. 2nd tier - Micro Frontend \u2693\ufe0e When dealing with internationalization - we obviously don't want to hardcode localized links in the source code of every micro frontend that we run with ILC. Instead, it's better to separate concerns. Such approach allows to be flexible in the selection of the localization pattern for your URLs, and you can manage this behaviour from central place. The other thing that we need to consider - is the fact that process & business logic of actual location.href un-localization before use in the app's router & localization of the URLs before rendering into the DOM should be synchronized across all applications and ILC itself. To achieve that ILC provides IlcIntl class via App SDK that can be used at CSR & SSR. Examples: - React with SSR Synchronized language/currency change \u2693\ufe0e When customer wants to change locale or currency on the website - it's often impossible to immediately render an updated content as loading of the localization files or updated prices is necessary. If we would only emit locale/currency change event and allow every micro frontend to deal with it on its own - customer would likely see \"blinking\" of the UI as various parts of it will be re-rendered in different moments of time. To prevent this from happening - ILC uses prepare/execute pattern to synchronize re-rendering of all micro frontends. Example: class Root extends React . Component { constructor ( props ) { super ( props ); this . state = { links : [] }; // This is a root React component, so it receives appSdk as property from ILC. const lang = this . props . appSdk . intl . get (). locale ; import ( `./links/ ${ lang } .json` ). then ( v => { this . setState ({ links : v . default }); }); } componentDidMount () { this . props . appSdk . intl . onChange ( ( e ) => import ( `./links/ ${ e . locale } .json` ), // Prepare all necessary data ( e , langModule ) => { // Perform language change this . setState ({ links : langModule . default }); } ); } changeLocale ( locale , e ) { e . preventDefault (); this . props . appSdk . intl . set ({ locale }); } render () { return ( < div className = 'navbar-app' > { this . state . links . map (( link ) => { return ( < NavLink key = { link . href } to = { this . props . appSdk . intl . localizeUrl ( link . href )} > { link . name } < /NavLink> ) }) } < div className = 'lang-selector' > < NativeListener onClick = { this . changeLocale . bind ( this , 'en-US' )} > < a href = \"#\" style = {{ color : 'white' }} > EN < /a> < /NativeListener> / < NativeListener onClick = { this . changeLocale . bind ( this , 'ua-UA' )} > < a href = \"#\" style = {{ color : 'white' }} > UA < /a> < /NativeListener> < /div> < /div> ); } }","title":"Internationalization"},{"location":"docs/i18n/#internationalization","text":"ILC comes with built in internationalization support, so you can easily run micro frontends on the websites which require support of the multiple languages. However, you need to keep in mind that ILC does only part of the job for you. Support of the i18n capabilities from the micro frontends side is required.","title":"Internationalization"},{"location":"docs/i18n/#routing","text":"ILC uses 2-tier routing model. It means that: 1. ILC itself handles only global routing (says which set of apps should be loaded at particular URL) 2. Micro Frontend has own routing in place which determines component to be rendered.","title":"Routing"},{"location":"docs/i18n/#1st-tier-ilc","text":"While having i18n feature enabled - ILC allows you to handle localized URLs at global level. Currently, we support two routing schemes: - Prefixing all routes with the locale except those of the default locale - Prefixing all routes with the locale In Registry, you continue to specify all routes in Registry w/o locale information.","title":"1st tier - ILC"},{"location":"docs/i18n/#2nd-tier-micro-frontend","text":"When dealing with internationalization - we obviously don't want to hardcode localized links in the source code of every micro frontend that we run with ILC. Instead, it's better to separate concerns. Such approach allows to be flexible in the selection of the localization pattern for your URLs, and you can manage this behaviour from central place. The other thing that we need to consider - is the fact that process & business logic of actual location.href un-localization before use in the app's router & localization of the URLs before rendering into the DOM should be synchronized across all applications and ILC itself. To achieve that ILC provides IlcIntl class via App SDK that can be used at CSR & SSR. Examples: - React with SSR","title":"2nd tier - Micro Frontend"},{"location":"docs/i18n/#synchronized-languagecurrency-change","text":"When customer wants to change locale or currency on the website - it's often impossible to immediately render an updated content as loading of the localization files or updated prices is necessary. If we would only emit locale/currency change event and allow every micro frontend to deal with it on its own - customer would likely see \"blinking\" of the UI as various parts of it will be re-rendered in different moments of time. To prevent this from happening - ILC uses prepare/execute pattern to synchronize re-rendering of all micro frontends. Example: class Root extends React . Component { constructor ( props ) { super ( props ); this . state = { links : [] }; // This is a root React component, so it receives appSdk as property from ILC. const lang = this . props . appSdk . intl . get (). locale ; import ( `./links/ ${ lang } .json` ). then ( v => { this . setState ({ links : v . default }); }); } componentDidMount () { this . props . appSdk . intl . onChange ( ( e ) => import ( `./links/ ${ e . locale } .json` ), // Prepare all necessary data ( e , langModule ) => { // Perform language change this . setState ({ links : langModule . default }); } ); } changeLocale ( locale , e ) { e . preventDefault (); this . props . appSdk . intl . set ({ locale }); } render () { return ( < div className = 'navbar-app' > { this . state . links . map (( link ) => { return ( < NavLink key = { link . href } to = { this . props . appSdk . intl . localizeUrl ( link . href )} > { link . name } < /NavLink> ) }) } < div className = 'lang-selector' > < NativeListener onClick = { this . changeLocale . bind ( this , 'en-US' )} > < a href = \"#\" style = {{ color : 'white' }} > EN < /a> < /NativeListener> / < NativeListener onClick = { this . changeLocale . bind ( this , 'ua-UA' )} > < a href = \"#\" style = {{ color : 'white' }} > UA < /a> < /NativeListener> < /div> < /div> ); } }","title":"Synchronized language/currency change"},{"location":"docs/ilc_app_interface/","text":"ILC to App interface \u2693\ufe0e ILC to App interface documentation","title":"ILC to App interface"},{"location":"docs/ilc_app_interface/#ilc-to-app-interface","text":"ILC to App interface documentation","title":"ILC to App interface"},{"location":"docs/installation_guide/","text":"Installing Isomorphic Layout Composer \u2693\ufe0e Production grade installation of the ILC consists from the deployment of 2 Docker images ( ILC & ILC Registry ) and 1 MySQL (5.7+) DB. It's recommended to use semver Docker tags (such as 1.1.0 ) to pin it to exact version of the image. In order to upgrade ILC to higher version you only need to replace running Docker images with a new version in the following order: Registry first, ILC itself after. So you should never have newer version of ILC running alongside outdated Registry. To get more information about exact configuration of the Docker images see docker-compose.yml Environment variables \u2693\ufe0e While most of the settings that are available in ILC are configurable through Registry UI or API there are certain system parameters that can be configured only via environment variables passed to Docker container. You can find full list of them in the following files: ILC container Registry container Authentication credentials configuration \u2693\ufe0e As soon as you'll get ILC up and running it's crucial to remove default access credentials and configure your own. See Registry: Authentication / Authorization doc for more details. High availability \u2693\ufe0e In order to deploy ILC in HA fashion you need to keep at least 2 instances of ILC, 2 of Registry and deploy MySQL in cluster mode (e.g. via AWS RDS Multi-AZ). It's worth to mention that ILC implements aggressive caching of the data from Registry so it can work for some time event w/o ability to communicate with Registry. Low response latency from Registry are also not really necessary for the same reason. Backup & restore \u2693\ufe0e ILC stores all user data in Registry DB. So regular MySQL backup/restore practices can be applied here. No special actions needed. Performance analytics with NewRelic \u2693\ufe0e ILC supports integration with NewRelic APM , NewRelic Browser and send custom metric to NewRelic Insights . To turn it on you need to pass your NewRelic license key in NR_LICENSE_KEY env variable to ILC & Registry containers. You can also wrap JS code that NR will generate if you have NewRelic Browser product enabled via NR_CUSTOM_CLIENT_JS_WRAPPER env variable. This may be useful for the compliance with GDPR customer settings. Example of usage: < script type = \"text/javascript\" >( function mygdprWrapper (){ % CONTENT % })()</ script > ` Custom metrics sent to Insights: * PageAction with Action Name routeChange . It contains duration of the reroute in ms.","title":"Installation"},{"location":"docs/installation_guide/#installing-isomorphic-layout-composer","text":"Production grade installation of the ILC consists from the deployment of 2 Docker images ( ILC & ILC Registry ) and 1 MySQL (5.7+) DB. It's recommended to use semver Docker tags (such as 1.1.0 ) to pin it to exact version of the image. In order to upgrade ILC to higher version you only need to replace running Docker images with a new version in the following order: Registry first, ILC itself after. So you should never have newer version of ILC running alongside outdated Registry. To get more information about exact configuration of the Docker images see docker-compose.yml","title":"Installing Isomorphic Layout Composer"},{"location":"docs/installation_guide/#environment-variables","text":"While most of the settings that are available in ILC are configurable through Registry UI or API there are certain system parameters that can be configured only via environment variables passed to Docker container. You can find full list of them in the following files: ILC container Registry container","title":"Environment variables"},{"location":"docs/installation_guide/#authentication-credentials-configuration","text":"As soon as you'll get ILC up and running it's crucial to remove default access credentials and configure your own. See Registry: Authentication / Authorization doc for more details.","title":"Authentication credentials configuration"},{"location":"docs/installation_guide/#high-availability","text":"In order to deploy ILC in HA fashion you need to keep at least 2 instances of ILC, 2 of Registry and deploy MySQL in cluster mode (e.g. via AWS RDS Multi-AZ). It's worth to mention that ILC implements aggressive caching of the data from Registry so it can work for some time event w/o ability to communicate with Registry. Low response latency from Registry are also not really necessary for the same reason.","title":"High availability"},{"location":"docs/installation_guide/#backup-restore","text":"ILC stores all user data in Registry DB. So regular MySQL backup/restore practices can be applied here. No special actions needed.","title":"Backup &amp; restore"},{"location":"docs/installation_guide/#performance-analytics-with-newrelic","text":"ILC supports integration with NewRelic APM , NewRelic Browser and send custom metric to NewRelic Insights . To turn it on you need to pass your NewRelic license key in NR_LICENSE_KEY env variable to ILC & Registry containers. You can also wrap JS code that NR will generate if you have NewRelic Browser product enabled via NR_CUSTOM_CLIENT_JS_WRAPPER env variable. This may be useful for the compliance with GDPR customer settings. Example of usage: < script type = \"text/javascript\" >( function mygdprWrapper (){ % CONTENT % })()</ script > ` Custom metrics sent to Insights: * PageAction with Action Name routeChange . It contains duration of the reroute in ms.","title":"Performance analytics with NewRelic"},{"location":"docs/microfrontend-types/","text":"Micro-frontend Types \u2693\ufe0e ILC has different categories of micro-frontends. It is up to you where and how you use each of them. However, here are some recommendations. Topic Applications Parcels Global libraries (coming soon...) SSR support yes no no Routing has multiple routes has no routes has no routes API declarative API imperative API exports a public interface Renders UI renders UI renders UI may or may not render UI Lifecycles ILC managed lifecycles custom managed lifecycles external module: no direct single-spa lifecycles When to use core building block to embed part of the one App into other useful to share common logic, or create a service Each ILC micro-frontend is an in-browser JavaScript module ( explanation ). Applications \u2693\ufe0e Applications are registered in ILC Registry and their lifecycle (when and where it should appear) is fully managed by ILC based on the Routers and Templates configuration. Applications act as a main building blocks for the website and can be rendered at the server side to enhance page loading timing and SEO/SMO metrics. Parcels in Applications \u2693\ufe0e It's also important to mention that applications can export Parcels and so they can allow parts of their UI to be used in other apps. See Parcel documentation for more details. Parcels \u2693\ufe0e Parcels exist primarily to allow you to reuse pieces of UI across applications when those applications are written in multiple frameworks. Think of parcels as an ILC specific implementation of webcomponents. See Parcel documentation for more details. Use case examples \u2693\ufe0e Contacts modal \u2693\ufe0e App1 handles everything related to contacts (highly cohesive) but somewhere in App2 we need to create a contact. We could do any number of things to share the functionality between application 1 and 2: If both are written in the same framework we could export/import components. We could reimplement creating a contact (loss of cohesion) We could use Parcels. Exporting a parcel from App1 that wraps the createContact modal component gives us the ability to share components and behavior across disparate frameworks, without losing application cohesion. App1 can export a modal as Parcel and App2 can import the parcel and use it easily.","title":"Micro-frontend Types"},{"location":"docs/microfrontend-types/#micro-frontend-types","text":"ILC has different categories of micro-frontends. It is up to you where and how you use each of them. However, here are some recommendations. Topic Applications Parcels Global libraries (coming soon...) SSR support yes no no Routing has multiple routes has no routes has no routes API declarative API imperative API exports a public interface Renders UI renders UI renders UI may or may not render UI Lifecycles ILC managed lifecycles custom managed lifecycles external module: no direct single-spa lifecycles When to use core building block to embed part of the one App into other useful to share common logic, or create a service Each ILC micro-frontend is an in-browser JavaScript module ( explanation ).","title":"Micro-frontend Types"},{"location":"docs/microfrontend-types/#applications","text":"Applications are registered in ILC Registry and their lifecycle (when and where it should appear) is fully managed by ILC based on the Routers and Templates configuration. Applications act as a main building blocks for the website and can be rendered at the server side to enhance page loading timing and SEO/SMO metrics.","title":"Applications"},{"location":"docs/microfrontend-types/#parcels-in-applications","text":"It's also important to mention that applications can export Parcels and so they can allow parts of their UI to be used in other apps. See Parcel documentation for more details.","title":"Parcels in Applications"},{"location":"docs/microfrontend-types/#parcels","text":"Parcels exist primarily to allow you to reuse pieces of UI across applications when those applications are written in multiple frameworks. Think of parcels as an ILC specific implementation of webcomponents. See Parcel documentation for more details.","title":"Parcels"},{"location":"docs/microfrontend-types/#use-case-examples","text":"","title":"Use case examples"},{"location":"docs/microfrontend-types/#contacts-modal","text":"App1 handles everything related to contacts (highly cohesive) but somewhere in App2 we need to create a contact. We could do any number of things to share the functionality between application 1 and 2: If both are written in the same framework we could export/import components. We could reimplement creating a contact (loss of cohesion) We could use Parcels. Exporting a parcel from App1 that wraps the createContact modal component gives us the ability to share components and behavior across disparate frameworks, without losing application cohesion. App1 can export a modal as Parcel and App2 can import the parcel and use it easily.","title":"Contacts modal"},{"location":"docs/multi-domains/","text":"Multi-domains \u2693\ufe0e ILC can handle requests coming from multiple domains, so that you don't need to roll out individual instances of the ILC for every domain, you just can use one instance for all of them. If you are going to use ILC only with one domain name, then this document is useless for you now. But when you decide to kick off developing at least under one more domain, then we recommend you come back and follow the steps below. How to add a new domain name \u2693\ufe0e Open ILC-Registry UI (at localhost by default it's run at http://localhost:4001/ ). In the left sidebar menu choose Router domains . Here will be store a list of all domains which are used under your ILC instance. Now we will add a new domain. At the top right corner, click Create . Enter your domain name in the Domain name field, e.g. \"example.com\". NB: you should provide only domain name, without protocol, etc. NBB: ILC uses a strict comparison of a domain name, which means if you enter \"example.com\" then sub-domains like \"foo.example.com\" won't work for you, so you should provide exactly \"foo.example.com\" in the Domain name field, if you are going to work with it. Choose the default 500 template in the Templete of 500 error field. We have a test route /_ilc/500 , so you can check it now, just open in browser \" https://your_domain.com/_ilc/500 \" NB: it's better to create personal template to handle 500 errors per each of your domains. Let's add the handler of the 404 error, to do it click on the Routes item in the left sidebar menu (you will be forwarded to this link). At the top of the body click on Show special , to set the checkbox to active state. You will see a list of special routes (for now there are routes only for 404 pages). NB: the 404 route without a specified domain name is can't be removed and is used as a fallback for all domains, so you can use one default 404 for all domains. At the top right corner, click Create special route (you will be forwarded to this link). In the Special role field choose 404 ; In the Domain field choose your domain; And other fields are the same as during the creation of simple routes. Now everything is set up and you can create your first route. To do it: Click again on Show special at the top of the body, to return to the list of simple routes; Off-topic: you can notice Domain's drop-down at the top of the body, with the help of it you can filter the list of domains, to work only with routes for a particular domain name. Then click Create at the top right corner During the creation of a route choose your domain name in the Domain field. If you need to move some old routes under newly created domain - just modify field Domain in their preferences. Open the route created in the previous step in a browser, to check if everything works as expected. Additional information \u2693\ufe0e ILC detects domain from the request.hostname of Fastify and checks if we have this hostname in the list of Router domains . link to documentation of Fastify's request Every registered domain in Router domains has it's own set of routes. They do not overlap. Domain is optional for routes, so if the request is going from the domain which is absent in Router domains - then routes w/o assigned domain will be used for routing.","title":"Multi-domains"},{"location":"docs/multi-domains/#multi-domains","text":"ILC can handle requests coming from multiple domains, so that you don't need to roll out individual instances of the ILC for every domain, you just can use one instance for all of them. If you are going to use ILC only with one domain name, then this document is useless for you now. But when you decide to kick off developing at least under one more domain, then we recommend you come back and follow the steps below.","title":"Multi-domains"},{"location":"docs/multi-domains/#how-to-add-a-new-domain-name","text":"Open ILC-Registry UI (at localhost by default it's run at http://localhost:4001/ ). In the left sidebar menu choose Router domains . Here will be store a list of all domains which are used under your ILC instance. Now we will add a new domain. At the top right corner, click Create . Enter your domain name in the Domain name field, e.g. \"example.com\". NB: you should provide only domain name, without protocol, etc. NBB: ILC uses a strict comparison of a domain name, which means if you enter \"example.com\" then sub-domains like \"foo.example.com\" won't work for you, so you should provide exactly \"foo.example.com\" in the Domain name field, if you are going to work with it. Choose the default 500 template in the Templete of 500 error field. We have a test route /_ilc/500 , so you can check it now, just open in browser \" https://your_domain.com/_ilc/500 \" NB: it's better to create personal template to handle 500 errors per each of your domains. Let's add the handler of the 404 error, to do it click on the Routes item in the left sidebar menu (you will be forwarded to this link). At the top of the body click on Show special , to set the checkbox to active state. You will see a list of special routes (for now there are routes only for 404 pages). NB: the 404 route without a specified domain name is can't be removed and is used as a fallback for all domains, so you can use one default 404 for all domains. At the top right corner, click Create special route (you will be forwarded to this link). In the Special role field choose 404 ; In the Domain field choose your domain; And other fields are the same as during the creation of simple routes. Now everything is set up and you can create your first route. To do it: Click again on Show special at the top of the body, to return to the list of simple routes; Off-topic: you can notice Domain's drop-down at the top of the body, with the help of it you can filter the list of domains, to work only with routes for a particular domain name. Then click Create at the top right corner During the creation of a route choose your domain name in the Domain field. If you need to move some old routes under newly created domain - just modify field Domain in their preferences. Open the route created in the previous step in a browser, to check if everything works as expected.","title":"How to add a new domain name"},{"location":"docs/multi-domains/#additional-information","text":"ILC detects domain from the request.hostname of Fastify and checks if we have this hostname in the list of Router domains . link to documentation of Fastify's request Every registered domain in Router domains has it's own set of routes. They do not overlap. Domain is optional for routes, so if the request is going from the domain which is absent in Router domains - then routes w/o assigned domain will be used for routing.","title":"Additional information"},{"location":"docs/parcels/","text":"Parcels \u2693\ufe0e Parcels are an advanced feature of ILC / single-spa. We recommend that you use Applications as the primary type of micro-frontend in your architecture. See this explanation for more details. ILC / single-spa parcel is a framework agnostic component. It is a chunk of functionality meant to be mounted manually by an application, without having to worry about which framework was used to implement the parcel or application. Parcels use similar methodology as registered applications but are mounted by a manual function call rather than the ILC itself. A parcel can be as large as an application or as small as a component and written in any language as long as it exports the correct lifecycle events. In ILC, your website contains many applications and each of those apps may additionally export Parcels. For now it's impossible to have Parcels exported not from the application's bundle. If you are only using one framework, it is recommended to prefer framework components (i.e., React, Vue, and Angular components) over Parcels. This is because framework components interop easier with each other than when there is an intermediate layer of ILC parcels. Demo & examples \u2693\ufe0e React \u2693\ufe0e Go to http://demo.microfrontends.online/people and click at the \"Open\" button to see Vue.js app being rendered within React one. Below you can find links to the source code which powers the demo from above. Parcel export , link to the full code , example: // app bundle entrypoint import ilcAdapterReact, { ParcelLifecycleFnProps } from 'ilc-adapter-react'; import Root from './root.component'; export default { ...ilcAdapterReact<AppLifecycleFnProps>({ rootComponent: Root, }), parcels: { person: ilcAdapterReact<ParcelLifecycleFnProps>({ loadRootComponent: () => import('./person.parcel.js').then(property('default')), }), }, }; // ./person.parcel.js import React from 'react'; import { ParcelLifecycleFnProps } from 'ilc-adapter-react'; export default (props: ParcelLifecycleFnProps) => { return <div>Hello world</div>; }; Parcel usage , link to the full code , small example: import Parcel from 'ilc-adapter-react/parcel'; export default () => ( <div> <Parcel loadingConfig={{ appName: '@portal/planets', parcelName: 'planet' }} wrapWith=\"div\" customParam1=\"testProp\" /> </div> ); Vue.js \u2693\ufe0e Go to http://demo.microfrontends.online/planets and click at the \"Open\" button to see React app being rendered within Vue.js one. Below you can find links to the source code which powers the demo from above. Parcel export , link to the full code , example: // app bundle entrypoint import Vue from 'vue'; import App from './App.vue'; import PlanetParcel from './planet-parcel.vue'; import singleSpaVue from 'ilc-adapter-vue'; export default { ...singleSpaVue({ Vue, appOptions: { render(h) { return h(App, { props: { mountParcel: this.mountParcel, } }) }, } }), parcels: { planet: singleSpaVue({ Vue, appOptions: { render(h) { return h(PlanetParcel, { props: { id: this.id, mountParcel: this.mountParcel, } }) }, } }) } }; Parcel usage , link to the full code , small example: Component which uses Parcel: <template> <div> <Parcel :config=\"parcelConfig()\" :mountParcel=\"mountParcel\" :parcelProps=\"getParcelProps()\" /> </div> </template> <script> import Parcel from 'single-spa-vue/dist/esm/parcel'; export default { components: { Parcel, }, data() { return { parcelConfig: () => window.ILC.importParcelFromApp('@portal/people', 'person') } }, methods: { getParcelProps() { return { id: 1, } }, }, inject: ['mountParcel'], } </script> App's root component (we use provide() / inject to pass mountParcel function to all child components): <script> export default { props: ['mountParcel'], provide() { return { mountParcel: this.mountParcel } } } </script> API \u2693\ufe0e ILC Parcels are 95% compatible with single-spa API . However - we've added some additions: - Additional lifecycle function properties which allow you to receive application properties from Registry as well as I18n config via ParcelSDK . - ILC favoured mountRootParcel . - ILC.importParcelFromApp - Convenient way to import parcel from app imperatively","title":"Parcels"},{"location":"docs/parcels/#parcels","text":"Parcels are an advanced feature of ILC / single-spa. We recommend that you use Applications as the primary type of micro-frontend in your architecture. See this explanation for more details. ILC / single-spa parcel is a framework agnostic component. It is a chunk of functionality meant to be mounted manually by an application, without having to worry about which framework was used to implement the parcel or application. Parcels use similar methodology as registered applications but are mounted by a manual function call rather than the ILC itself. A parcel can be as large as an application or as small as a component and written in any language as long as it exports the correct lifecycle events. In ILC, your website contains many applications and each of those apps may additionally export Parcels. For now it's impossible to have Parcels exported not from the application's bundle. If you are only using one framework, it is recommended to prefer framework components (i.e., React, Vue, and Angular components) over Parcels. This is because framework components interop easier with each other than when there is an intermediate layer of ILC parcels.","title":"Parcels"},{"location":"docs/parcels/#demo-examples","text":"","title":"Demo &amp; examples"},{"location":"docs/parcels/#react","text":"Go to http://demo.microfrontends.online/people and click at the \"Open\" button to see Vue.js app being rendered within React one. Below you can find links to the source code which powers the demo from above. Parcel export , link to the full code , example: // app bundle entrypoint import ilcAdapterReact, { ParcelLifecycleFnProps } from 'ilc-adapter-react'; import Root from './root.component'; export default { ...ilcAdapterReact<AppLifecycleFnProps>({ rootComponent: Root, }), parcels: { person: ilcAdapterReact<ParcelLifecycleFnProps>({ loadRootComponent: () => import('./person.parcel.js').then(property('default')), }), }, }; // ./person.parcel.js import React from 'react'; import { ParcelLifecycleFnProps } from 'ilc-adapter-react'; export default (props: ParcelLifecycleFnProps) => { return <div>Hello world</div>; }; Parcel usage , link to the full code , small example: import Parcel from 'ilc-adapter-react/parcel'; export default () => ( <div> <Parcel loadingConfig={{ appName: '@portal/planets', parcelName: 'planet' }} wrapWith=\"div\" customParam1=\"testProp\" /> </div> );","title":"React"},{"location":"docs/parcels/#vuejs","text":"Go to http://demo.microfrontends.online/planets and click at the \"Open\" button to see React app being rendered within Vue.js one. Below you can find links to the source code which powers the demo from above. Parcel export , link to the full code , example: // app bundle entrypoint import Vue from 'vue'; import App from './App.vue'; import PlanetParcel from './planet-parcel.vue'; import singleSpaVue from 'ilc-adapter-vue'; export default { ...singleSpaVue({ Vue, appOptions: { render(h) { return h(App, { props: { mountParcel: this.mountParcel, } }) }, } }), parcels: { planet: singleSpaVue({ Vue, appOptions: { render(h) { return h(PlanetParcel, { props: { id: this.id, mountParcel: this.mountParcel, } }) }, } }) } }; Parcel usage , link to the full code , small example: Component which uses Parcel: <template> <div> <Parcel :config=\"parcelConfig()\" :mountParcel=\"mountParcel\" :parcelProps=\"getParcelProps()\" /> </div> </template> <script> import Parcel from 'single-spa-vue/dist/esm/parcel'; export default { components: { Parcel, }, data() { return { parcelConfig: () => window.ILC.importParcelFromApp('@portal/people', 'person') } }, methods: { getParcelProps() { return { id: 1, } }, }, inject: ['mountParcel'], } </script> App's root component (we use provide() / inject to pass mountParcel function to all child components): <script> export default { props: ['mountParcel'], provide() { return { mountParcel: this.mountParcel } } } </script>","title":"Vue.js"},{"location":"docs/parcels/#api","text":"ILC Parcels are 95% compatible with single-spa API . However - we've added some additions: - Additional lifecycle function properties which allow you to receive application properties from Registry as well as I18n config via ParcelSDK . - ILC favoured mountRootParcel . - ILC.importParcelFromApp - Convenient way to import parcel from app imperatively","title":"API"},{"location":"docs/registry/","text":"ILC Registry \u2693\ufe0e The registry provides a Rest API and UI to publish, update, and retrieve micro frontends, templates and routes configuration. It's available at 4001 port by default (use http://127.0.0.1:4001 for locally launched ILC). Authentication / Authorization \u2693\ufe0e Currently Registry supports authentication only, all authenticated entities will receive all permissions possible. As for now we support 3 authentication providers: OpenID Connect. Turned off by default. Locally configured login/password. Default credentials: root / pwd Locally configured Bearer token for API machine-to-machine access. Default credentials: Bearer cm9vdF9hcGlfdG9rZW4=:dG9rZW5fc2VjcmV0 (after base64 decode it's Bearer root_api_token:token_secret ). Default credentials can be changed via \"Auth entities\" page through UI (or via API). OpenID Configuration \u2693\ufe0e See auth.openid.* keys at \"Settings\" page in Registry to configure OpenID. Sample configuration ( note that values are JSON encoded ): key value baseUrl \"https://ilc-registry.example.com/\" auth.openid.enabled true auth.openid.discoveryUrl \"https://adfs.example.com/adfs/\" auth.openid.clientId \"ba34c345-e543-6554-b0be-3e1097ddd32d\" auth.openid.clientSecret \"XXXXXX\" Attention: OpenID Connect returnURL should be specified at provider as follows: {baseUrl}/auth/openid/return User Interface \u2693\ufe0e API \u2693\ufe0e Currently there is no documentation for each API endpoint. However you can use network tab to see how UI communicates with API or feel free to explore code starting from here /registry/server/app.ts Update of the JS/CSS URLs during micro-frontends deployment \u2693\ufe0e It's a usual pattern to store JS/CSS files of the micro-frontend apps at CDN using unique URLs (ex: https://nc-img.com/layoutfragments-ui/app.80de7d4e36eae32662d2.js ). While following this approach we need to update links to the JS/CSS bundles in registry after every deployment. To do so we have at least 3 options: * Manually via UI ( not recommended ) * Using Registry API (see API endpoints for more info) * Using App Assets Discovery mechanism While registering micro-frontend in ILC Registry it's possible to set \"Assets discovery url\" which will be examined periodically by Registry. The idea is that this file will contain actual references to the JS/CSS bundles and updated at CDN right after every deploy. Example file: // https://nc-img.com/layoutfragments-ui/assets-discovery.json { \"spaBundle\": \"https://nc-img.com/layoutfragments-ui/app.80de7d4e36eae32662d2.js\", \"cssBundle\": \"./app.81340a47f3122508fd76.css\", //It's possible to use relative links which will be resolved against manifest URL \"dependencies\": { \"react\": \"https://unpkg.com/react@16.13.1/umd/react.production.min.js\" } }","title":"ILC Registry"},{"location":"docs/registry/#ilc-registry","text":"The registry provides a Rest API and UI to publish, update, and retrieve micro frontends, templates and routes configuration. It's available at 4001 port by default (use http://127.0.0.1:4001 for locally launched ILC).","title":"ILC Registry"},{"location":"docs/registry/#authentication-authorization","text":"Currently Registry supports authentication only, all authenticated entities will receive all permissions possible. As for now we support 3 authentication providers: OpenID Connect. Turned off by default. Locally configured login/password. Default credentials: root / pwd Locally configured Bearer token for API machine-to-machine access. Default credentials: Bearer cm9vdF9hcGlfdG9rZW4=:dG9rZW5fc2VjcmV0 (after base64 decode it's Bearer root_api_token:token_secret ). Default credentials can be changed via \"Auth entities\" page through UI (or via API).","title":"Authentication / Authorization"},{"location":"docs/registry/#openid-configuration","text":"See auth.openid.* keys at \"Settings\" page in Registry to configure OpenID. Sample configuration ( note that values are JSON encoded ): key value baseUrl \"https://ilc-registry.example.com/\" auth.openid.enabled true auth.openid.discoveryUrl \"https://adfs.example.com/adfs/\" auth.openid.clientId \"ba34c345-e543-6554-b0be-3e1097ddd32d\" auth.openid.clientSecret \"XXXXXX\" Attention: OpenID Connect returnURL should be specified at provider as follows: {baseUrl}/auth/openid/return","title":"OpenID Configuration"},{"location":"docs/registry/#user-interface","text":"","title":"User Interface"},{"location":"docs/registry/#api","text":"Currently there is no documentation for each API endpoint. However you can use network tab to see how UI communicates with API or feel free to explore code starting from here /registry/server/app.ts","title":"API"},{"location":"docs/registry/#update-of-the-jscss-urls-during-micro-frontends-deployment","text":"It's a usual pattern to store JS/CSS files of the micro-frontend apps at CDN using unique URLs (ex: https://nc-img.com/layoutfragments-ui/app.80de7d4e36eae32662d2.js ). While following this approach we need to update links to the JS/CSS bundles in registry after every deployment. To do so we have at least 3 options: * Manually via UI ( not recommended ) * Using Registry API (see API endpoints for more info) * Using App Assets Discovery mechanism While registering micro-frontend in ILC Registry it's possible to set \"Assets discovery url\" which will be examined periodically by Registry. The idea is that this file will contain actual references to the JS/CSS bundles and updated at CDN right after every deploy. Example file: // https://nc-img.com/layoutfragments-ui/assets-discovery.json { \"spaBundle\": \"https://nc-img.com/layoutfragments-ui/app.80de7d4e36eae32662d2.js\", \"cssBundle\": \"./app.81340a47f3122508fd76.css\", //It's possible to use relative links which will be resolved against manifest URL \"dependencies\": { \"react\": \"https://unpkg.com/react@16.13.1/umd/react.production.min.js\" } }","title":"Update of the JS/CSS URLs during micro-frontends deployment"},{"location":"docs/transition_hooks/","text":"ILC transition hooks \u2693\ufe0e ILC provides an opportunity to check a route before navigate to it and the only thing that you need to do to handle it is to create ILC transition hooks plugin with the help of ILC plugins SDK to cover any cases that depend on access to any routes. ILC transition hooks plugin \u2693\ufe0e ILC transition hooks plugin should follow a specific interface that is provided by ILC plugins SDK for this plugin. ILC gets transition hooks from a plugin and calls them before navigating to a route. It works for CSR and SSR . You have the following several options what to do with a navigation event: Stop navigation and use your custom behavior such as authentication form as an example to navigate whenever you need then ( CSR ); Redirect to a new location ( CSR , SSR ); Continue navigation ( CSR , SSR ). Every transition hook receives route information ( URL , route meta information that a route has in ILC registry ) from ILC. Provided information allows you to handle only specific routes that you need. As an example, you can mark some routes as protected in meta field of a route in ILC registry and do something with navigation to those marked routes. There is a default ILC transition hooks plugin in ILC plugins SDK that you can use an example. Server side API \u2693\ufe0e Transition hooks are async on server side. Every hook receives route information, ILC logger and current request on server side from ILC. Important! You have to use that provided ILC logger when you need to log something inside of your hook because ILC has own log interface on server side, so every application or plugin should follow it. Client side API \u2693\ufe0e Transition hooks are sync on client side and ILC calls them per each History change event. Every hook receives route information and navigate method on client side from ILC. Important! Whenever you need to navigate to a route from your hook you need to use that provided navigate method to keep ILC SPA routing mechanism safe. Demo \u2693\ufe0e You can see an example how it works in ILC on our demo website .","title":"ILC transition hooks"},{"location":"docs/transition_hooks/#ilc-transition-hooks","text":"ILC provides an opportunity to check a route before navigate to it and the only thing that you need to do to handle it is to create ILC transition hooks plugin with the help of ILC plugins SDK to cover any cases that depend on access to any routes.","title":"ILC transition hooks"},{"location":"docs/transition_hooks/#ilc-transition-hooks-plugin","text":"ILC transition hooks plugin should follow a specific interface that is provided by ILC plugins SDK for this plugin. ILC gets transition hooks from a plugin and calls them before navigating to a route. It works for CSR and SSR . You have the following several options what to do with a navigation event: Stop navigation and use your custom behavior such as authentication form as an example to navigate whenever you need then ( CSR ); Redirect to a new location ( CSR , SSR ); Continue navigation ( CSR , SSR ). Every transition hook receives route information ( URL , route meta information that a route has in ILC registry ) from ILC. Provided information allows you to handle only specific routes that you need. As an example, you can mark some routes as protected in meta field of a route in ILC registry and do something with navigation to those marked routes. There is a default ILC transition hooks plugin in ILC plugins SDK that you can use an example.","title":"ILC transition hooks plugin"},{"location":"docs/transition_hooks/#server-side-api","text":"Transition hooks are async on server side. Every hook receives route information, ILC logger and current request on server side from ILC. Important! You have to use that provided ILC logger when you need to log something inside of your hook because ILC has own log interface on server side, so every application or plugin should follow it.","title":"Server side API"},{"location":"docs/transition_hooks/#client-side-api","text":"Transition hooks are sync on client side and ILC calls them per each History change event. Every hook receives route information and navigate method on client side from ILC. Important! Whenever you need to navigate to a route from your hook you need to use that provided navigate method to keep ILC SPA routing mechanism safe.","title":"Client side API"},{"location":"docs/transition_hooks/#demo","text":"You can see an example how it works in ILC on our demo website .","title":"Demo"},{"location":"docs/umd_bundles_compatibility/","text":"Compatibility with legacy UMD bundles \u2693\ufe0e When adding ILC to the legacy website - sometimes you may face an issue when code that you still load via regular <script> tags may work incorrectly. This happens when you load external libraries packed as UMD bundles. By default, ILC exposes window.define variable - which forces all UMD bundles to be registered within ILC (through System.js). While this approach is convenient for the new projects - it may break things on the legacy ones. As without ILC and System.js running you expect content of the UMD bundle to be registered as window variable. In order to fix the issue - you need to enable the following flag on Registry Settings page: amdDefineCompatibilityMode=true . This will remove window.define variable so all your libs should instead use window.ILC.define . When using webpack - here is how you can force usage of window.ILC.define while building the apps for ILC: const ilcWebpackPluginsFactory = require ( 'ilc-sdk' ). WebpackPluginsFactory ; module . exports = { entry : 'src/app.js' , output : { filename : 'app.js' , libraryTarget : 'amd' , }, module : { /* ... */ }, plugins : ilcWebpackPluginsFactory (). client , };","title":"Compatibility with legacy UMD bundles"},{"location":"docs/umd_bundles_compatibility/#compatibility-with-legacy-umd-bundles","text":"When adding ILC to the legacy website - sometimes you may face an issue when code that you still load via regular <script> tags may work incorrectly. This happens when you load external libraries packed as UMD bundles. By default, ILC exposes window.define variable - which forces all UMD bundles to be registered within ILC (through System.js). While this approach is convenient for the new projects - it may break things on the legacy ones. As without ILC and System.js running you expect content of the UMD bundle to be registered as window variable. In order to fix the issue - you need to enable the following flag on Registry Settings page: amdDefineCompatibilityMode=true . This will remove window.define variable so all your libs should instead use window.ILC.define . When using webpack - here is how you can force usage of window.ILC.define while building the apps for ILC: const ilcWebpackPluginsFactory = require ( 'ilc-sdk' ). WebpackPluginsFactory ; module . exports = { entry : 'src/app.js' , output : { filename : 'app.js' , libraryTarget : 'amd' , }, module : { /* ... */ }, plugins : ilcWebpackPluginsFactory (). client , };","title":"Compatibility with legacy UMD bundles"},{"location":"docs/routing/introduction/","text":"Introduction \u2693\ufe0e Most JavaScript frameworks come with a dedicated routing solution like angular/router or vue-router . They allow you to navigate through pages of an application without a full page refresh on every click. Problem statement \u2693\ufe0e When you have a monolithic application, it handles all the routes on its own. When there are two or more applications, they also handle all their routes independently. Since, by default, one independent application know nothing about routes and pages of other independent application. This gives you a problem to solve - a routing issue. Routing basics \u2693\ufe0e Before proceeding with details on how the issue is handled by ILC, get familiar with the basics of routing in the micro-frontends and terminology: Hard navigation describes a page transition where the browser loads the complete HTML for the next page from the server. Soft navigation describes a page transition that is rendered entirely on the client-side, typically by using a client-side router. In this scenario, the client fetches data from the server via API. Solution \u2693\ufe0e There are several approaches to implement navigation. The common ones are described below: Page transitions happen via plain links, which results in a full page refresh. To proceed with this approach, Team A must know how to link to the pages of Team B and vice versa. No special tooling is required. All transitions inside team boundaries are soft. Hard navigation happens when the user crosses team boundaries. From an architectural perspective, this approach is the same as the first one because Team A still has to know how to link to the pages of Team B (and vice versa) regardless of the details of the internal implementation. ILC uses a third approach called Unified SPA (Unified Single-page application). It introduces a central application container (that is, ILC) that handles page transitions between the teams. In this approach, all the transitions are soft. Implementation of routing in ILC: In ILC, you can use one HTML template for all of your applications. With this approach, page load occurs only once (during the first time load), after that all navigation occurs via CSR (client-side rendering). In addition to the fact that all navigation inside the ILC is soft, it also uses two-tiered routing which, unlike the flat routing approach - where, in ILC, you need to specify a full URL of each page of all your applications, allows we to specify only a base URL of the application in the ILC and that's it, we don't need to know the full route to each page of the application. All navigation within the application can be implemented by each development team using their application's own tools (for example, react-router, or vue-router). In the example above, the user opened the /news/latest page URL. ILC checks the first part of the URL ( /news/ ) to determine the assosiated application. It correlates to the /news/* route configured in ILC. This route contains information about applications that should be loaded on the page and props these applications need to receive. When the application is loaded and mounted to its container DOM node, it also receives basePath property that should be used by application's router. The application's router processes the complete URL to find the correct page inside its SPA. You can use native tools (for example <Link> in React router ) to navigate between pages within the application, and global link - a link ( <a> tag) to navigate between applications. In ILC, as mentioned before, the transition between applications occurs via the <a> tags. To do this, ILC keeps track of all <a> tags on the page and handles clicks on them, provided that: Tag contains a non-empty href . event.PreventDefault does not equal false . target does not equal _self . This is not a special url ( mailto , tel , etc). If one of the above points is not met, ILC ignores the processing of the clicks on the link. Conclusion \u2693\ufe0e ILC acts as a wrapper for other applications making all the transitions soft. Furthermore, it uses two-level routing so that teams can configure routing inside their application as they need to, whereas, in ILC, you only need to specify the path to the application.","title":"Introduction"},{"location":"docs/routing/introduction/#introduction","text":"Most JavaScript frameworks come with a dedicated routing solution like angular/router or vue-router . They allow you to navigate through pages of an application without a full page refresh on every click.","title":"Introduction"},{"location":"docs/routing/introduction/#problem-statement","text":"When you have a monolithic application, it handles all the routes on its own. When there are two or more applications, they also handle all their routes independently. Since, by default, one independent application know nothing about routes and pages of other independent application. This gives you a problem to solve - a routing issue.","title":"Problem statement"},{"location":"docs/routing/introduction/#routing-basics","text":"Before proceeding with details on how the issue is handled by ILC, get familiar with the basics of routing in the micro-frontends and terminology: Hard navigation describes a page transition where the browser loads the complete HTML for the next page from the server. Soft navigation describes a page transition that is rendered entirely on the client-side, typically by using a client-side router. In this scenario, the client fetches data from the server via API.","title":"Routing basics"},{"location":"docs/routing/introduction/#solution","text":"There are several approaches to implement navigation. The common ones are described below: Page transitions happen via plain links, which results in a full page refresh. To proceed with this approach, Team A must know how to link to the pages of Team B and vice versa. No special tooling is required. All transitions inside team boundaries are soft. Hard navigation happens when the user crosses team boundaries. From an architectural perspective, this approach is the same as the first one because Team A still has to know how to link to the pages of Team B (and vice versa) regardless of the details of the internal implementation. ILC uses a third approach called Unified SPA (Unified Single-page application). It introduces a central application container (that is, ILC) that handles page transitions between the teams. In this approach, all the transitions are soft. Implementation of routing in ILC: In ILC, you can use one HTML template for all of your applications. With this approach, page load occurs only once (during the first time load), after that all navigation occurs via CSR (client-side rendering). In addition to the fact that all navigation inside the ILC is soft, it also uses two-tiered routing which, unlike the flat routing approach - where, in ILC, you need to specify a full URL of each page of all your applications, allows we to specify only a base URL of the application in the ILC and that's it, we don't need to know the full route to each page of the application. All navigation within the application can be implemented by each development team using their application's own tools (for example, react-router, or vue-router). In the example above, the user opened the /news/latest page URL. ILC checks the first part of the URL ( /news/ ) to determine the assosiated application. It correlates to the /news/* route configured in ILC. This route contains information about applications that should be loaded on the page and props these applications need to receive. When the application is loaded and mounted to its container DOM node, it also receives basePath property that should be used by application's router. The application's router processes the complete URL to find the correct page inside its SPA. You can use native tools (for example <Link> in React router ) to navigate between pages within the application, and global link - a link ( <a> tag) to navigate between applications. In ILC, as mentioned before, the transition between applications occurs via the <a> tags. To do this, ILC keeps track of all <a> tags on the page and handles clicks on them, provided that: Tag contains a non-empty href . event.PreventDefault does not equal false . target does not equal _self . This is not a special url ( mailto , tel , etc). If one of the above points is not met, ILC ignores the processing of the clicks on the link.","title":"Solution"},{"location":"docs/routing/introduction/#conclusion","text":"ILC acts as a wrapper for other applications making all the transitions soft. Furthermore, it uses two-level routing so that teams can configure routing inside their application as they need to, whereas, in ILC, you only need to specify the path to the application.","title":"Conclusion"},{"location":"docs/routing/localization_and_trailing_slash/","text":"System settings: i18n and Trailing slash \u2693\ufe0e i18n \u2693\ufe0e ILC comes with built-in internationalization support. However, ILC only handles localized URLs at the global level. Currently, it supports two routing schemes that can be switched in the i18n.routingStrategy menu: Prefix except default - prefix all routes with the locale except those of the default locale. Prefix - prefix all routes with the locale i18n settings allow you to change page language and currency, however, prefixes are used in localization settings only. Currency selection doesn't affect the URL and doesn't add or delete a prefix. In Registry, you specify all the routes without the locale information. More details about i18n are available in the Internationalization page . Trailing slash \u2693\ufe0e A trailing slash is a forward slash ( / ) symbol at the end of a URL. ILC allows you to manage cases with a trailing slash, but the decision to use it is at your discretion, considering personal preference and special cases you may have. To manage trailing slash behavior, there are the following options: Do nothing - No effect at URLs. Redirect to non-trailing slash - It redirects to the URL without a trailing slash at the end. Redirect to trailing slash - It redirects to the URL with a trailing slash at the end.","title":"i18n & trailing slash"},{"location":"docs/routing/localization_and_trailing_slash/#system-settings-i18n-and-trailing-slash","text":"","title":"System settings: i18n and Trailing slash"},{"location":"docs/routing/localization_and_trailing_slash/#i18n","text":"ILC comes with built-in internationalization support. However, ILC only handles localized URLs at the global level. Currently, it supports two routing schemes that can be switched in the i18n.routingStrategy menu: Prefix except default - prefix all routes with the locale except those of the default locale. Prefix - prefix all routes with the locale i18n settings allow you to change page language and currency, however, prefixes are used in localization settings only. Currency selection doesn't affect the URL and doesn't add or delete a prefix. In Registry, you specify all the routes without the locale information. More details about i18n are available in the Internationalization page .","title":"i18n"},{"location":"docs/routing/localization_and_trailing_slash/#trailing-slash","text":"A trailing slash is a forward slash ( / ) symbol at the end of a URL. ILC allows you to manage cases with a trailing slash, but the decision to use it is at your discretion, considering personal preference and special cases you may have. To manage trailing slash behavior, there are the following options: Do nothing - No effect at URLs. Redirect to non-trailing slash - It redirects to the URL without a trailing slash at the end. Redirect to trailing slash - It redirects to the URL with a trailing slash at the end.","title":"Trailing slash"},{"location":"docs/routing/route_configuration_options/","text":"Route configuration options \u2693\ufe0e Route domains \u2693\ufe0e ILC can handle requests coming from multiple domains, so you can use a single ILC instance to handle them instead of rolling out individual instances for every domain. ILC checks the exact match of domain names. It means that secure.example.com is not equal to example.com , and you may need to add the necessary subdomains to handle this case properly. Domain name must be without protocol. Empty Domain Name field means the main app domain. To add a new domain, go to the Router domains section in the sidebar. Add a new domain ILC renders applications for only one domain at the same time. To add one header to several domains, you need to create the same route several times specifying the required domain for each route. For example: where: - render for the main domain - render for the 127.0.0.1 domain only More information about domains is available in the Multi-domains page . Route template \u2693\ufe0e Template is an HTML file that is used to build the structure of your page. If it is missing in the routing chain, ILC won't be able to render your content properly and will throw an error. Important note There must be at least one template in the routing chain. To create a template, go to the Templates section in the sidebar. Route metadata \u2693\ufe0e The Metadata field is handled by plugins, not by ILC. For example, ILC has the Transition hooks plugin installed by default. This plugin determines whether the page should be protected. If yes, it will grant access to the protected page only after the user fulfills the required conditions. ILC also supports custom plugins. You can learn more about them in the ilc-plugins-sdk repository Supported options \u2693\ufe0e protected . Type: boolean Access the protected page \u2693\ufe0e In the basic scenario, the required condition to access the protected page is to press the confirm button. In real world scenarios, you can set any conditions (for example, authorization form). More information about the Transition hooks plugin is available in the ILC transition hooks page . Slot configuration \u2693\ufe0e Slot configuration defines the main settings of a route: application; where the application should be displayed; how critical this application is for our site\u044a create/change application properties Configuration \u2693\ufe0e Slot name Slot name refers to the value of the id attribute of the corresponding ilc-slot in the ILC templates. Your application will be rendered inside the ilc-slot with the id that you specify in the Slot name . </ head > < body > < ilc-slot id = \"navbar\" /> < ilc-slot id = \"body\" /> < ilc-slot id = \"footer\" /> </ body > </ html > Important note You can have only one application per slot. If you add multiple applications to one slot, only the latter one will be rendered. App name App name refers to the application that will be rendered in the specified slot. Applications in the list are defined in the Apps section in the sidebar. App type There are the following app types: Primary : set for the vital applications of your site . If the application crashes on the server side, ILC won't render it on the client side, and will immediately render an error. Essential : set for the vital applications for the user (for example, header). If the application crashes on the server side, ILC will try to render it on the client side. It will render an error only if the application crashes on both server and client sides. Regular : set for non-critical applications (for example, footer). If the application crashes on both server and client sides, ILC won't render it on the client side and will ignore errors from it. Props field Props allow you to configure the application separately for each route. With props, you can override the props specified when creating the application in the Apps section in the sidebar.","title":"Route configuration"},{"location":"docs/routing/route_configuration_options/#route-configuration-options","text":"","title":"Route configuration options"},{"location":"docs/routing/route_configuration_options/#route-domains","text":"ILC can handle requests coming from multiple domains, so you can use a single ILC instance to handle them instead of rolling out individual instances for every domain. ILC checks the exact match of domain names. It means that secure.example.com is not equal to example.com , and you may need to add the necessary subdomains to handle this case properly. Domain name must be without protocol. Empty Domain Name field means the main app domain. To add a new domain, go to the Router domains section in the sidebar. Add a new domain ILC renders applications for only one domain at the same time. To add one header to several domains, you need to create the same route several times specifying the required domain for each route. For example: where: - render for the main domain - render for the 127.0.0.1 domain only More information about domains is available in the Multi-domains page .","title":"Route domains"},{"location":"docs/routing/route_configuration_options/#route-template","text":"Template is an HTML file that is used to build the structure of your page. If it is missing in the routing chain, ILC won't be able to render your content properly and will throw an error. Important note There must be at least one template in the routing chain. To create a template, go to the Templates section in the sidebar.","title":"Route template"},{"location":"docs/routing/route_configuration_options/#route-metadata","text":"The Metadata field is handled by plugins, not by ILC. For example, ILC has the Transition hooks plugin installed by default. This plugin determines whether the page should be protected. If yes, it will grant access to the protected page only after the user fulfills the required conditions. ILC also supports custom plugins. You can learn more about them in the ilc-plugins-sdk repository","title":"Route metadata"},{"location":"docs/routing/route_configuration_options/#supported-options","text":"protected . Type: boolean","title":"Supported options"},{"location":"docs/routing/route_configuration_options/#access-the-protected-page","text":"In the basic scenario, the required condition to access the protected page is to press the confirm button. In real world scenarios, you can set any conditions (for example, authorization form). More information about the Transition hooks plugin is available in the ILC transition hooks page .","title":"Access the protected page"},{"location":"docs/routing/route_configuration_options/#slot-configuration","text":"Slot configuration defines the main settings of a route: application; where the application should be displayed; how critical this application is for our site\u044a create/change application properties","title":"Slot configuration"},{"location":"docs/routing/route_configuration_options/#configuration","text":"Slot name Slot name refers to the value of the id attribute of the corresponding ilc-slot in the ILC templates. Your application will be rendered inside the ilc-slot with the id that you specify in the Slot name . </ head > < body > < ilc-slot id = \"navbar\" /> < ilc-slot id = \"body\" /> < ilc-slot id = \"footer\" /> </ body > </ html > Important note You can have only one application per slot. If you add multiple applications to one slot, only the latter one will be rendered. App name App name refers to the application that will be rendered in the specified slot. Applications in the list are defined in the Apps section in the sidebar. App type There are the following app types: Primary : set for the vital applications of your site . If the application crashes on the server side, ILC won't render it on the client side, and will immediately render an error. Essential : set for the vital applications for the user (for example, header). If the application crashes on the server side, ILC will try to render it on the client side. It will render an error only if the application crashes on both server and client sides. Regular : set for non-critical applications (for example, footer). If the application crashes on both server and client sides, ILC won't render it on the client side and will ignore errors from it. Props field Props allow you to configure the application separately for each route. With props, you can override the props specified when creating the application in the Apps section in the sidebar.","title":"Configuration"},{"location":"docs/routing/route_matching_patterns/","text":"Route matching patterns \u2693\ufe0e Match and cascade merge \u2693\ufe0e Route field \u2693\ufe0e * - Matches any route. / - Matches home page only. /news/* - Matches /news/ route and any subroute (for example, /news/blablabla ). /wrapper/ - Matches only /wrapper/ route and ignores any subroute (for example, /wrapper/blablabla ). Important note Route must be unique for each domain. Exception is * - you can use the same order position, provided that the domain names are different. Order field \u2693\ufe0e The order field is an integer value that specifies the order in which the fragments should be fetched when constructing pages. ILC goes through positions from lowest to highest. To specify order position, you can use integer numbers (only) from -\u221e to +\u221e . For more details, refer to the Examples section below. Important note Order positions must be unique for each domain. You can use the same order position, provided that the domain names are different. Next field \u2693\ufe0e The next field is a boolean value that instructs ILC on whether should it move further ( true ) through the list of applications, or stop ( false ) after rendering the current one. Examples \u2693\ufe0e Prerequisites \u2693\ufe0e Before proceeding with the examples, ensure that your routing table looks as follows: /wrapper/ route \u2693\ufe0e After configuring your routing table , navigate to the http://demo.microfrontends.online/wrapper/ ILC side: ILC starts with the application with the lowest Order pos value (in this case, -100 ). Its route is * , so it is rendered . The Next field is set to true , so ILC goes further to the next route. ILC moves further to position Order pos -1 . It does not render it because the /simple/ route does not match the given one. ILC moves further to position Order pos 0 . It renders this application because its route is * . The Next field is set to true , so ILC goes further to the next route. The applications with Order pos 3 , 10 , 20 , and 30 are not rendered because their route does not match the specified one. The Next field is set to true , so ILC goes further to the next route. ILC moves further to position Order pos 40 . This is the exact match of the specified route. This application is rendered . The Next field is set to false , so IL\u0421 stops. As a result, there are 3 rendered applications for both * routes and for /wrapper/ route. Render a page with navbar only \u2693\ufe0e In this example, you will instruct ILC to render the navbar and skip rendering of the application at the Order pos 0 and route * . You will be working with the /wrapper/ example route. To do this: Set the Order pos for the /wrapper/ route to any number between -100 and 0 . For example, -2 . Make sure that the Next field for the /wrapper/ route is set to false . Explanation Since you want to skip rendering of the application that has the Order pos 0 , considering that navbar has the Order pos -100 , you need to define your /wrapper/ route at any place after the navbar but before the application ( -100 < number < 0 ). ILC side: ILC starts with the application with the lowest Order pos value (in this case, -100 ). Its route is * , so it is rendered . The Next field is set to true , so ILC goes further to the next route. ILC moves further to position Order pos -2 . It renders this application because it is a match. The Next field is set to false , so IL\u0421 stops. /people/blablabla/ route \u2693\ufe0e Since ILC registry already contains the /people/* value, ILC renders both * and /people/* routes. Conclusion \u2693\ufe0e As you can see from the examples above, Order pos can be used to flexibly manipulate the content you want to show. A quick recap: Let's say, you have a page with the following elements: application , sidebar , navbar , footer . To skip rendering of a particular element(s), change Order pos of your application accordingly. See the examples below: Render all elements Skip sidebar Skip sidebar and navbar Skip sidebar, navbar, and footer footer : Order pos -1000 navbar : Order pos -100 sidebar : Order pos 0 application : Order pos 5 footer : Order pos -1000 navbar : Order pos -100 application : Order pos -50 sidebar : Order pos 0 footer : Order pos -1000 application : Order pos -200 navbar : Order pos -100 sidebar : Order pos 0 application : Order pos -1200 footer : Order pos -1000 navbar : Order pos -100 sidebar : Order pos 0","title":"Route matching patterns"},{"location":"docs/routing/route_matching_patterns/#route-matching-patterns","text":"","title":"Route matching patterns"},{"location":"docs/routing/route_matching_patterns/#match-and-cascade-merge","text":"","title":"Match and cascade merge"},{"location":"docs/routing/route_matching_patterns/#route-field","text":"* - Matches any route. / - Matches home page only. /news/* - Matches /news/ route and any subroute (for example, /news/blablabla ). /wrapper/ - Matches only /wrapper/ route and ignores any subroute (for example, /wrapper/blablabla ). Important note Route must be unique for each domain. Exception is * - you can use the same order position, provided that the domain names are different.","title":"Route field"},{"location":"docs/routing/route_matching_patterns/#order-field","text":"The order field is an integer value that specifies the order in which the fragments should be fetched when constructing pages. ILC goes through positions from lowest to highest. To specify order position, you can use integer numbers (only) from -\u221e to +\u221e . For more details, refer to the Examples section below. Important note Order positions must be unique for each domain. You can use the same order position, provided that the domain names are different.","title":"Order field"},{"location":"docs/routing/route_matching_patterns/#next-field","text":"The next field is a boolean value that instructs ILC on whether should it move further ( true ) through the list of applications, or stop ( false ) after rendering the current one.","title":"Next field"},{"location":"docs/routing/route_matching_patterns/#examples","text":"","title":"Examples"},{"location":"docs/routing/route_matching_patterns/#prerequisites","text":"Before proceeding with the examples, ensure that your routing table looks as follows:","title":"Prerequisites"},{"location":"docs/routing/route_matching_patterns/#wrapper-route","text":"After configuring your routing table , navigate to the http://demo.microfrontends.online/wrapper/ ILC side: ILC starts with the application with the lowest Order pos value (in this case, -100 ). Its route is * , so it is rendered . The Next field is set to true , so ILC goes further to the next route. ILC moves further to position Order pos -1 . It does not render it because the /simple/ route does not match the given one. ILC moves further to position Order pos 0 . It renders this application because its route is * . The Next field is set to true , so ILC goes further to the next route. The applications with Order pos 3 , 10 , 20 , and 30 are not rendered because their route does not match the specified one. The Next field is set to true , so ILC goes further to the next route. ILC moves further to position Order pos 40 . This is the exact match of the specified route. This application is rendered . The Next field is set to false , so IL\u0421 stops. As a result, there are 3 rendered applications for both * routes and for /wrapper/ route.","title":"/wrapper/ route"},{"location":"docs/routing/route_matching_patterns/#render-a-page-with-navbar-only","text":"In this example, you will instruct ILC to render the navbar and skip rendering of the application at the Order pos 0 and route * . You will be working with the /wrapper/ example route. To do this: Set the Order pos for the /wrapper/ route to any number between -100 and 0 . For example, -2 . Make sure that the Next field for the /wrapper/ route is set to false . Explanation Since you want to skip rendering of the application that has the Order pos 0 , considering that navbar has the Order pos -100 , you need to define your /wrapper/ route at any place after the navbar but before the application ( -100 < number < 0 ). ILC side: ILC starts with the application with the lowest Order pos value (in this case, -100 ). Its route is * , so it is rendered . The Next field is set to true , so ILC goes further to the next route. ILC moves further to position Order pos -2 . It renders this application because it is a match. The Next field is set to false , so IL\u0421 stops.","title":"Render a page with navbar only"},{"location":"docs/routing/route_matching_patterns/#peopleblablabla-route","text":"Since ILC registry already contains the /people/* value, ILC renders both * and /people/* routes.","title":"/people/blablabla/ route"},{"location":"docs/routing/route_matching_patterns/#conclusion","text":"As you can see from the examples above, Order pos can be used to flexibly manipulate the content you want to show. A quick recap: Let's say, you have a page with the following elements: application , sidebar , navbar , footer . To skip rendering of a particular element(s), change Order pos of your application accordingly. See the examples below: Render all elements Skip sidebar Skip sidebar and navbar Skip sidebar, navbar, and footer footer : Order pos -1000 navbar : Order pos -100 sidebar : Order pos 0 application : Order pos 5 footer : Order pos -1000 navbar : Order pos -100 application : Order pos -50 sidebar : Order pos 0 footer : Order pos -1000 application : Order pos -200 navbar : Order pos -100 sidebar : Order pos 0 application : Order pos -1200 footer : Order pos -1000 navbar : Order pos -100 sidebar : Order pos 0","title":"Conclusion"},{"location":"docs/routing/route_transition_and_animation/","text":"Route transition and animation \u2693\ufe0e Overview \u2693\ufe0e As you may have read in intoduction , all transitions in the ILC are soft. It means that you can add, remove, and replace applications on the page without reloading thanks to the use of one HTML template for all pages. This template contains so-called ilc-slots that are used to render applications. (one application per slot at a time). For example: In this example, the routing table looks as follows: Whereas the HTML template contains two ilc-slots: < body > < ilc-slot id = \"navbar\" /> < ilc-slot id = \"body\" /> </ body > Navigate to the /wrapper/ route. In this case, ILC will render the application in both slots: the navigation bar ( ) in the navbar slot, and the main app ( ) in the body slot. Navigate to the /hooks/ route. The application inside the body slot will be replaced, while the navigation bar will stay in place. Navigate to the /noheader/ route. For this route, there is only one application specified that is rendered inside the body slot. The navbar slot is empty now. Routing within applications can be processed natively by application tools instead of the ILC. With this routing, the content will always be located inside the same ILC slot. Animation capabilities \u2693\ufe0e Regardless of system optimization or how well your product design is, there will always be a point where the user has to wait. For these cases, ILC has a built-in feature to display a spinner when loading an application. Global spinner \u2693\ufe0e There are the following settings to configure spinner behavior: globalSpinner.enabled - enable or disable the display of the spinner. globalSpinner.customHTML - add your custom spinner. We recommend using more progressive tools like Skeleton loader - a placeholder for the information that is still loading that mimics the look and structure of the entire view.","title":"Route transition and animation"},{"location":"docs/routing/route_transition_and_animation/#route-transition-and-animation","text":"","title":"Route transition and animation"},{"location":"docs/routing/route_transition_and_animation/#overview","text":"As you may have read in intoduction , all transitions in the ILC are soft. It means that you can add, remove, and replace applications on the page without reloading thanks to the use of one HTML template for all pages. This template contains so-called ilc-slots that are used to render applications. (one application per slot at a time). For example: In this example, the routing table looks as follows: Whereas the HTML template contains two ilc-slots: < body > < ilc-slot id = \"navbar\" /> < ilc-slot id = \"body\" /> </ body > Navigate to the /wrapper/ route. In this case, ILC will render the application in both slots: the navigation bar ( ) in the navbar slot, and the main app ( ) in the body slot. Navigate to the /hooks/ route. The application inside the body slot will be replaced, while the navigation bar will stay in place. Navigate to the /noheader/ route. For this route, there is only one application specified that is rendered inside the body slot. The navbar slot is empty now. Routing within applications can be processed natively by application tools instead of the ILC. With this routing, the content will always be located inside the same ILC slot.","title":"Overview"},{"location":"docs/routing/route_transition_and_animation/#animation-capabilities","text":"Regardless of system optimization or how well your product design is, there will always be a point where the user has to wait. For these cases, ILC has a built-in feature to display a spinner when loading an application.","title":"Animation capabilities"},{"location":"docs/routing/route_transition_and_animation/#global-spinner","text":"There are the following settings to configure spinner behavior: globalSpinner.enabled - enable or disable the display of the spinner. globalSpinner.customHTML - add your custom spinner. We recommend using more progressive tools like Skeleton loader - a placeholder for the information that is still loading that mimics the look and structure of the entire view.","title":"Global spinner"},{"location":"docs/routing/special_routes/","text":"Error handling in router \u2693\ufe0e \u0421urrently, ILC can handle 404 and 5XX errors only. This document describes the implementation of errors in ILC. Since in the micro frontends, a webpage consists of several fragments, the approach to handling errors differs from that used in monolithic frontends. '404' error \u2693\ufe0e To see 404 error routes, use the Show special switcher at the top of the routes page. Special route must be created separately for each domain. Unlike simple routes that use composition with the help of the Next property, the special route has its own configuration. It means that you must add the template and all the necessary applications (for example, header, footer) to the Special route slot (see the screenshot below). More information about the 404 error is available in the Global error handling page . '5XX' errors \u2693\ufe0e ILC render this error as a simple HTML file. This consideration is made to minimize the chances of error occurrence on rendering since if ILC fails, this HTML file will be used by the browser to show an error to the user. The 500 template acts as the default error template for the main domain. To assign different error templates to domains, you must specify the template when creating a domain. See the screenshots below. Preview error In ILC, it is possible to preview the 500 error via the /_ilc/500/ route. For example: http://demo.microfrontends.online/_ilc/500 is the preview route for the demo website. More information about the 5xx errors handling is available in the Global error handling page .","title":"Special routes"},{"location":"docs/routing/special_routes/#error-handling-in-router","text":"\u0421urrently, ILC can handle 404 and 5XX errors only. This document describes the implementation of errors in ILC. Since in the micro frontends, a webpage consists of several fragments, the approach to handling errors differs from that used in monolithic frontends.","title":"Error handling in router"},{"location":"docs/routing/special_routes/#404-error","text":"To see 404 error routes, use the Show special switcher at the top of the routes page. Special route must be created separately for each domain. Unlike simple routes that use composition with the help of the Next property, the special route has its own configuration. It means that you must add the template and all the necessary applications (for example, header, footer) to the Special route slot (see the screenshot below). More information about the 404 error is available in the Global error handling page .","title":"'404' error"},{"location":"docs/routing/special_routes/#5xx-errors","text":"ILC render this error as a simple HTML file. This consideration is made to minimize the chances of error occurrence on rendering since if ILC fails, this HTML file will be used by the browser to show an error to the user. The 500 template acts as the default error template for the main domain. To assign different error templates to domains, you must specify the template when creating a domain. See the screenshots below. Preview error In ILC, it is possible to preview the 500 error via the /_ilc/500/ route. For example: http://demo.microfrontends.online/_ilc/500 is the preview route for the demo website. More information about the 5xx errors handling is available in the Global error handling page .","title":"'5XX' errors"},{"location":"docs/stepbystep/","text":"Step by step apps creation with ILC \u2693\ufe0e This section is dedicated to the step by step lessons on how you can create apps that will work in pair with ILC. React \u2693\ufe0e Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"App deployments with ILC"},{"location":"docs/stepbystep/#step-by-step-apps-creation-with-ilc","text":"This section is dedicated to the step by step lessons on how you can create apps that will work in pair with ILC.","title":"Step by step apps creation with ILC"},{"location":"docs/stepbystep/#react","text":"Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"React"},{"location":"docs/stepbystep/react/lesson1/","text":"Step by step apps creation with ILC, React, Lesson 1 \u2693\ufe0e Hi folks! This document will teach you how to create simple isomorphic React application and run it with ILC in few minutes. So buckle in your seat belt and let's get started \ud83d\ude80 We need React app with SSR first \u2693\ufe0e As you might already guess to build new micro frontend we need to have regular application first. Hopefully I already did all the dirty job for you dear reader. So you can go and grab it here https://github.com/StyleT/ilc-learning-react . Or you can use https://codesandbox.io/s/github/StyleT/ilc-learning-react to have it running for you in the cloud. As soon as you started the app - try to play few tic-tac-toe matches \ud83d\ude0e Adapting the app to ILC \u2693\ufe0e To make the application work correctly with ILC we need to make it compliant with ILC to App interface . Fortunately that's pretty easy, go through the source code and resolve all the //TODO: comments I placed for you there. As soon as you're finished with this - restart the app & try to open /microfrontend route. You should get 200 OK response code & some SSR markup. Note: in case of any troubles - try to switch to the \"step_1-ILC_integration\" branch in the repo - it has all the changes already done for you. Configuring ILC to handle new app \u2693\ufe0e In this step we're gonna use our public demo website and \" Develop right at \"production\" \" ILC feature to complete the task. We will do it for the sake of simplicity only. However you can achieve pretty the same results using ILC that you run locally. To make your new fancy micro frontend work we need to determine your publicPath & ssrPath first. If you're using codesandbox.io (recommended approach) Your publicPath will be somewhat like https://abcde.sse.codesandbox.io/public/ . Check the address bar of your virtual browser. And your ssrPath will be https://abcde.sse.codesandbox.io/microfrontend If you're running app locally Your publicPath will be http://127.0.0.1:5000/public/ . And your ssrPath will be http://XXX.XXX.XXX.XXX:5000/microfrontend where you need to replace XXX with the white IP address of your machine. You can use services like https://ngrok.com/ to get one if your Internet provider keeps you behind NAT. As soon as you've figured out all the details - let's change the ILC config for us. To do so you need to open http://demo.microfrontends.online/nosuchpath and execute the following code in browser console: var publicPath = 'https://abcde.sse.codesandbox.io/public/' ; var ssrPath = 'https://abcde.sse.codesandbox.io/microfrontend' ; var overrideConfig = encodeURIComponent ( JSON . stringify ({ apps : { '@portal/myapp' : { spaBundle : publicPath + 'client.js' , cssBundle : publicPath + 'style.css' , ssr : { src : ssrPath , timeout : 10000 , }, props : { publicPath }, kind : 'primary' , }, }, routes : [{ routeId : 555 , route : '/nosuchpath' , slots : { body : { appName : '@portal/myapp' } } }] })); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;` Refresh the page after code execution. If you did everything correctly - you should be able to see your app running inside public ILC demo website. If it doesn't work for you - ensure that ssrPath is accessible not only from your machine and JS/CSS links are actually working.","title":"Lesson 1"},{"location":"docs/stepbystep/react/lesson1/#step-by-step-apps-creation-with-ilc-react-lesson-1","text":"Hi folks! This document will teach you how to create simple isomorphic React application and run it with ILC in few minutes. So buckle in your seat belt and let's get started \ud83d\ude80","title":"Step by step apps creation with ILC, React, Lesson 1"},{"location":"docs/stepbystep/react/lesson1/#we-need-react-app-with-ssr-first","text":"As you might already guess to build new micro frontend we need to have regular application first. Hopefully I already did all the dirty job for you dear reader. So you can go and grab it here https://github.com/StyleT/ilc-learning-react . Or you can use https://codesandbox.io/s/github/StyleT/ilc-learning-react to have it running for you in the cloud. As soon as you started the app - try to play few tic-tac-toe matches \ud83d\ude0e","title":"We need React app with SSR first"},{"location":"docs/stepbystep/react/lesson1/#adapting-the-app-to-ilc","text":"To make the application work correctly with ILC we need to make it compliant with ILC to App interface . Fortunately that's pretty easy, go through the source code and resolve all the //TODO: comments I placed for you there. As soon as you're finished with this - restart the app & try to open /microfrontend route. You should get 200 OK response code & some SSR markup. Note: in case of any troubles - try to switch to the \"step_1-ILC_integration\" branch in the repo - it has all the changes already done for you.","title":"Adapting the app to ILC"},{"location":"docs/stepbystep/react/lesson1/#configuring-ilc-to-handle-new-app","text":"In this step we're gonna use our public demo website and \" Develop right at \"production\" \" ILC feature to complete the task. We will do it for the sake of simplicity only. However you can achieve pretty the same results using ILC that you run locally. To make your new fancy micro frontend work we need to determine your publicPath & ssrPath first. If you're using codesandbox.io (recommended approach) Your publicPath will be somewhat like https://abcde.sse.codesandbox.io/public/ . Check the address bar of your virtual browser. And your ssrPath will be https://abcde.sse.codesandbox.io/microfrontend If you're running app locally Your publicPath will be http://127.0.0.1:5000/public/ . And your ssrPath will be http://XXX.XXX.XXX.XXX:5000/microfrontend where you need to replace XXX with the white IP address of your machine. You can use services like https://ngrok.com/ to get one if your Internet provider keeps you behind NAT. As soon as you've figured out all the details - let's change the ILC config for us. To do so you need to open http://demo.microfrontends.online/nosuchpath and execute the following code in browser console: var publicPath = 'https://abcde.sse.codesandbox.io/public/' ; var ssrPath = 'https://abcde.sse.codesandbox.io/microfrontend' ; var overrideConfig = encodeURIComponent ( JSON . stringify ({ apps : { '@portal/myapp' : { spaBundle : publicPath + 'client.js' , cssBundle : publicPath + 'style.css' , ssr : { src : ssrPath , timeout : 10000 , }, props : { publicPath }, kind : 'primary' , }, }, routes : [{ routeId : 555 , route : '/nosuchpath' , slots : { body : { appName : '@portal/myapp' } } }] })); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;` Refresh the page after code execution. If you did everything correctly - you should be able to see your app running inside public ILC demo website. If it doesn't work for you - ensure that ssrPath is accessible not only from your machine and JS/CSS links are actually working.","title":"Configuring ILC to handle new app"},{"location":"docs/stepbystep/react/lesson2/","text":"Step by step apps creation with ILC, React, Lesson 2 \u2693\ufe0e This article is the continuation of the first one that can be found here . However if you're an experienced developer \u2013 feel free to start from this one. In this part we'll showcase how to turn an app that uses React router into Micro Frontend that works with Isomorphic Layout Composer . A bit of theory... \u2693\ufe0e One of the first questions that you need to solve when applying micro frontends architecture is routing. It comes from the fact that you no longer have a single React/Vue.js/etc app that handles all the route transitions. Now you have multiple apps working simultaneously on the web page, and you somehow need to understand which apps should be active on the page for the current URL. We, in Isomorphic Layout Composer (ILC), solve this by using so-called \"2-tiered routing\" approach. In this example the user opened a page at /news/latest URL. It correlates to the /news/* route configured in ILC, this route contains information about apps that should be loaded on the page and props they need to receive. When we load and mount the application to its container DOM node \u2013 we also pass basePath property which should be used by application's router during its work. But enough theory \u2013 let's see some real code. Starting point \u2693\ufe0e We'll start from the sample React app that has 3 internal routes: Home, Tic-Tac-Toe game and Snake game. Please go and grab it here: https://github.com/StyleT/ilc-learning-react/tree/step_2-Router (you need to use step_2-Router branch). After git clone, run npm i && npm start . Or you can use codesandbox.io to have it running for you in the cloud. I would recommend to use codesandbox.io to eliminate all the local environment related issues that may appear as we move forward. As soon as you started the app \u2013 try to go through the links in the menu, disable JavaScript execution to see SSR output, etc... If you just finished the 1st lesson \u2013 look at the diff between master branch and step_2-Router . See what was changed. Adapting the app to ILC \u2693\ufe0e To make our React app play together with ILC \u2013 we need to make it compliant with ILC to App interface . Fortunately that's pretty easy, go through the source code and resolve all the //TODO: comments I placed for you there. As soon as you're finished with this \u2013 restart the app and try to open /microfrontend route. You should get 200 OK response code & some SSR markup. Note: in case of any troubles \u2013 try to switch to the step_2-Router_ILC_integrated branch in the repo \u2013 it has all the changes already done for you. Configuring ILC to handle new app \u2693\ufe0e In this step we're gonna use our public demo website and \" Develop right at \"production\" \" ILC feature to complete the task. We will do it for the sake of simplicity only. However you can achieve pretty the same results using ILC that you run locally. More info about how to determine public & SSR paths for your particular case \u2013 you can find in the previous lesson . Now let's open demo.microfrontends.online/nosuchpath and by setting \"magic cookie\" in our browser \u2013 let's change ILC config on the fly: var publicPath = 'https://abcde.sse.codesandbox.io/public/' ; var ssrPath = 'https://abcde.sse.codesandbox.io/microfrontend' ; var overrideConfig = encodeURIComponent ( JSON . stringify ({ apps : { '@portal/myapp' : { spaBundle : publicPath + 'client.js' , cssBundle : publicPath + 'style.css' , ssr : { src : ssrPath , timeout : 10000 , }, props : { publicPath }, kind : 'primary' , }, }, routes : [{ routeId : 555 , route : '/nosuchpath/*' , slots : { body : { appName : '@portal/myapp' } } }] })); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;` Refresh the page after code execution. If you did everything correctly \u2013 you should be able to see your app running inside a public ILC demo website. If it doesn't work for you \u2013 ensure that ssrPath is accessible not only from your machine (use https://reqbin.com/ ) and JS/CSS links are actually working from your machine. Exploring the results \u2693\ufe0e Now you can try to play some Tic-Tac-Toe and Snake games by following the links to the corresponding pages within your own Micro Frontend \ud83d\ude0e Pay attention to the \"Demo News app\" link. Even despite the fact that it's a regular <a> tag \u2013 it doesn't cause page reload and smoothly loads another app. This is one of the features of the ILC that help to make it work with legacy monolithic apps. Also try to disable JS execution and go through the links again. See that all of the pages look exactly as with JS enabled (apart from the fact that you can't play games now). Summary \u2693\ufe0e In a matter of a half an hour we turned the simplest React-router based app into a Micro Frontend and I hope it went nice and easy for you. Micro Frontends architecture is quite complex when you start to work with it. But a proper toolchain that Isomorphic Layout Composer delivers \u2013 can simplify things a lot.","title":"Lesson 2"},{"location":"docs/stepbystep/react/lesson2/#step-by-step-apps-creation-with-ilc-react-lesson-2","text":"This article is the continuation of the first one that can be found here . However if you're an experienced developer \u2013 feel free to start from this one. In this part we'll showcase how to turn an app that uses React router into Micro Frontend that works with Isomorphic Layout Composer .","title":"Step by step apps creation with ILC, React, Lesson 2"},{"location":"docs/stepbystep/react/lesson2/#a-bit-of-theory","text":"One of the first questions that you need to solve when applying micro frontends architecture is routing. It comes from the fact that you no longer have a single React/Vue.js/etc app that handles all the route transitions. Now you have multiple apps working simultaneously on the web page, and you somehow need to understand which apps should be active on the page for the current URL. We, in Isomorphic Layout Composer (ILC), solve this by using so-called \"2-tiered routing\" approach. In this example the user opened a page at /news/latest URL. It correlates to the /news/* route configured in ILC, this route contains information about apps that should be loaded on the page and props they need to receive. When we load and mount the application to its container DOM node \u2013 we also pass basePath property which should be used by application's router during its work. But enough theory \u2013 let's see some real code.","title":"A bit of theory..."},{"location":"docs/stepbystep/react/lesson2/#starting-point","text":"We'll start from the sample React app that has 3 internal routes: Home, Tic-Tac-Toe game and Snake game. Please go and grab it here: https://github.com/StyleT/ilc-learning-react/tree/step_2-Router (you need to use step_2-Router branch). After git clone, run npm i && npm start . Or you can use codesandbox.io to have it running for you in the cloud. I would recommend to use codesandbox.io to eliminate all the local environment related issues that may appear as we move forward. As soon as you started the app \u2013 try to go through the links in the menu, disable JavaScript execution to see SSR output, etc... If you just finished the 1st lesson \u2013 look at the diff between master branch and step_2-Router . See what was changed.","title":"Starting point"},{"location":"docs/stepbystep/react/lesson2/#adapting-the-app-to-ilc","text":"To make our React app play together with ILC \u2013 we need to make it compliant with ILC to App interface . Fortunately that's pretty easy, go through the source code and resolve all the //TODO: comments I placed for you there. As soon as you're finished with this \u2013 restart the app and try to open /microfrontend route. You should get 200 OK response code & some SSR markup. Note: in case of any troubles \u2013 try to switch to the step_2-Router_ILC_integrated branch in the repo \u2013 it has all the changes already done for you.","title":"Adapting the app to ILC"},{"location":"docs/stepbystep/react/lesson2/#configuring-ilc-to-handle-new-app","text":"In this step we're gonna use our public demo website and \" Develop right at \"production\" \" ILC feature to complete the task. We will do it for the sake of simplicity only. However you can achieve pretty the same results using ILC that you run locally. More info about how to determine public & SSR paths for your particular case \u2013 you can find in the previous lesson . Now let's open demo.microfrontends.online/nosuchpath and by setting \"magic cookie\" in our browser \u2013 let's change ILC config on the fly: var publicPath = 'https://abcde.sse.codesandbox.io/public/' ; var ssrPath = 'https://abcde.sse.codesandbox.io/microfrontend' ; var overrideConfig = encodeURIComponent ( JSON . stringify ({ apps : { '@portal/myapp' : { spaBundle : publicPath + 'client.js' , cssBundle : publicPath + 'style.css' , ssr : { src : ssrPath , timeout : 10000 , }, props : { publicPath }, kind : 'primary' , }, }, routes : [{ routeId : 555 , route : '/nosuchpath/*' , slots : { body : { appName : '@portal/myapp' } } }] })); document . cookie = `ILC-overrideConfig= ${ overrideConfig } ; path=/;` Refresh the page after code execution. If you did everything correctly \u2013 you should be able to see your app running inside a public ILC demo website. If it doesn't work for you \u2013 ensure that ssrPath is accessible not only from your machine (use https://reqbin.com/ ) and JS/CSS links are actually working from your machine.","title":"Configuring ILC to handle new app"},{"location":"docs/stepbystep/react/lesson2/#exploring-the-results","text":"Now you can try to play some Tic-Tac-Toe and Snake games by following the links to the corresponding pages within your own Micro Frontend \ud83d\ude0e Pay attention to the \"Demo News app\" link. Even despite the fact that it's a regular <a> tag \u2013 it doesn't cause page reload and smoothly loads another app. This is one of the features of the ILC that help to make it work with legacy monolithic apps. Also try to disable JS execution and go through the links again. See that all of the pages look exactly as with JS enabled (apart from the fact that you can't play games now).","title":"Exploring the results"},{"location":"docs/stepbystep/react/lesson2/#summary","text":"In a matter of a half an hour we turned the simplest React-router based app into a Micro Frontend and I hope it went nice and easy for you. Micro Frontends architecture is quite complex when you start to work with it. But a proper toolchain that Isomorphic Layout Composer delivers \u2013 can simplify things a lot.","title":"Summary"},{"location":"docs/stepbystep/react/lesson3/","text":"Step by step apps creation with ILC, React, Lesson 3 \u2693\ufe0e Hi folks! This document will teach you how to add state handling to the app we've created in previous lesson. TBD \u2693\ufe0e","title":"Lesson 3"},{"location":"docs/stepbystep/react/lesson3/#step-by-step-apps-creation-with-ilc-react-lesson-3","text":"Hi folks! This document will teach you how to add state handling to the app we've created in previous lesson.","title":"Step by step apps creation with ILC, React, Lesson 3"},{"location":"docs/stepbystep/react/lesson3/#tbd","text":"","title":"TBD"},{"location":"docs/stepbystep/react/lesson4/","text":"Step by step apps creation with ILC, React, Lesson 4 \u2693\ufe0e Hi folks! This document will teach you how to add title & meta tags handling with the help of react-helmet to the app we've created in previous lesson. TBD \u2693\ufe0e","title":"Lesson 4"},{"location":"docs/stepbystep/react/lesson4/#step-by-step-apps-creation-with-ilc-react-lesson-4","text":"Hi folks! This document will teach you how to add title & meta tags handling with the help of react-helmet to the app we've created in previous lesson.","title":"Step by step apps creation with ILC, React, Lesson 4"},{"location":"docs/stepbystep/react/lesson4/#tbd","text":"","title":"TBD"}]}